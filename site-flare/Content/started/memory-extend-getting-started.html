<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
    <head>
    </head>
    <body>
        <h1>Getting Started with MemoryXtend</h1>
        <p> In a traditional deployment, all data grid entries are stored in RAM to provide the fastest performance possible. However, while RAM performs better than SSD, it is also more expensive. As SSD gains in popularity, we see new scenarios where storing part of the data in SSD and part in RAM provides great business value. The MemoryXtend (blobstore) storage model allows an external storage medium (one that does not reside on the JVM heap) to store the Space data.</p>
        <p>This section provides an example that demonstrates  how to setup MemoryXtend, storing part of the data in SSD. To continue working with the feature, see the <a href="../admin/memoryxtend-overview.html">MemoryXtend</a> section for detailed usage and implementation.</p>
        <div class="tc-admon-note">
            <p>Set up a project - see <a href="insightedge-in-5-minutes.html">InsightEdge in 5 minutes</a> </p>
        </div>
        <p>&#160;</p>
        <h1>Adding MemoryXtend in DataGrid</h1>
        <p>We will utilize the available RAM storage and continue to store the most used (hot) data, and store the less used (warm) data in SSD. In this example we will work with 3 types of data, with data types 0, 1 and 2. We configure that data is stored in SSD, that is persistent and therefore available after the processing unit is redeployed. Data type 1 is also stored in RAM for faster access.</p>
        <ol>
            <li>
                <p>Modify the feeder's configuration file, pu.xml to limit the types of data in this exercise:</p>
                <p>Change numberOfTypes to 3 in .../feeder/src/main/resources/META-INF/spring/pu.xml.</p>
            </li>
            <li>Modify the processor's configuration file, pu.xml (.../processor/src/main/resources/META-INF/spring/pu.xml) to include the blobstore that allows external storage medium to store the data.<ol style="list-style-type: lower-alpha;"><li><p>Add these entries to define the blobstore in the schema definition:</p><pre xml:space="preserve"><code class="language-java">xmlns:blob-store="http://www.openspaces.org/schema/rocksdb-blob-store" </code></pre><pre xml:space="preserve"><code class="language-java">http://www.openspaces.org/schema/rocksdb-blob-store http://www.openspaces.org/schema/14.0/rocksdb-blob-store/openspaces-rocksdb-blobstore.xsd</code></pre></li><li><p>Add the blobstore that includes 4 instances with mapping directory to these paths</p><pre><code class="language-java">&lt;blob-store:rocksdb-blob-store id="rocksDbBlobstore" paths="[/tmp/memory-xtend-demo/db1,/tmp/memory-xtend-demo/db2,/tmp/memory-xtend-demo/db3,/tmp/memory-xtend-demo/db4]" mapping-dir="/tmp/memory-xtend-demo/mapping"/&gt;</code></pre><li><p>Modify the Space definition to include the blobstore, so it stores data persistently in the SSD layer, and data type 1 stored also in RAM.</p><pre><code class="language-xml">&lt;os-core:space id="space" url="/./space"&gt;
    &lt;os-core:blob-store-data-policy persistent="true" blob-store-handler="rocksDbBlobstore"&gt;
        &lt;os-core:blob-store-cache-query class="com.gigaspaces.demo.common.Data" where="type = 1"/&gt;
    &lt;/os-core:blob-store-data-policy&gt;
&lt;/os-core:space&gt;</code></pre></li></li></ol></li>
        </ol>
        <h1>Verifying Extended Memory</h1>
        <p>Verity that extended memory is deployed correctly and data is now fetched from SSD layer.</p>
        <ol>
            <li>Build the project again.<br /></li>
            <li>Deploy the processing unit again and run the query:</li>
        </ol><pre xml:space="preserve">select UID, * from com.gigaspaces.demo.common.Data</pre>
        <ol>
            <p>Since data was stored persistently in SSD, all data types are fetched.</p>
            <p style="color: #ff0000;" MadCap:conditions="Default.DraftOnly">ED NOTE: The recording from Alex has additional round of undeploy/deploy  but results/purpose are not clear, so omitted (for now) - Niv also looking at it. The main point of demo has already been achieved without these steps, </p>
            <li MadCap:conditions="Default.DoNotShow"><span style="color: #ff0000;">Undeploy the processing unit.</span>
            </li>
            <li style="color: #ff0000;" MadCap:conditions="Default.DoNotShow">Re-deploy the processing unit and verify that data with type 1 is fetched from the SSD layer.<p style="color: #ff0000;">Run the query  in Management Console and verify there is no data with type 1</p><pre xml:space="preserve">select UID, * from com.gigaspaces.demo.common.Data</pre></li>
        </ol>
        <p>Other storage options are:</p>
        <ul>
            <li><a href="insightedge-in-5-minutes.html#https://docs-staging.gigaspaces.com/14.5/admin/memoryxtend-pmem.html?Highlight=pmem">Persistent Memory</a> (PMEM) that provides performance similar to RAM, but at a cost closer to that of SSD</li>
            <li><a href="insightedge-in-5-minutes.html#https://docs-staging.gigaspaces.com/14.5/admin/memoryxtend-ohr.html">Off-Heap RAM </a>that stores space objects in RAM outside the Hava heap, that provides better RAM utilization</li>
        </ul>
    </body>
</html>