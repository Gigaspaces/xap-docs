<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
    <head>
    </head>
    <body>
        <div class="product-bar">
            <p><a><MadCap:variable name="General.ProductXAP" /></a>
            </p>
        </div>
        <div class="product-bar">
            <p><a>Smart DIH</a>
            </p>
        </div>
        <h1 class="tc-pagetitle"><a name="Smart_Document_API"></a>Document API</h1>
        <p>Unlike POJOs, which force users to design a fixed data schema (in the form of a class definition) and adhere to it, a Document is much more dynamic - users can add and remove properties at runtime as necessary. A Document always belongs to a certain type, represented by the class <code>SpaceTypeDescriptor</code>.</p>
        <p>Before a certain Document instance is written to the Space, its type should be introduced to it. The type has a name and controls metadata such as identifier property, routing property and which properties are initially indexed (naturally, you can also index new properties at runtime after adding them to your Documents).</p>
        <div class="tc-admon-note">
            <p>The Type controls <span class="tc-bold">metadata</span>, so only the metadata is part of the type. A Document can introduce new properties at will.</p>
        </div>
        <p>Note that the Document type does not describe the properties themselves (except for the names of the ID and Routing properties). These are completely dynamic and each instance can have a different set of properties, although in most cases Document instances of the same type are likely to have identical or similar set of properties.</p>
        <p><a name="Smart_Schema_Evolution"></a>
        </p>
        <h1><a name="schema-evolution"></a>Schema Evolution</h1>
        <p>A <code>SpaceDocument</code> is completely dynamic by nature, so it is very easy to change or evolve your data model without taking down the Space. Simply change your application code to add additional properties or remove existing ones, and you're good to go. Even better, old and new versions can co-exist because the Space doesn't enforce any restrictions regarding the property set of Documents that belong to a certain type. This is a much more lightweight model in comparison to the classic POJO model, where a recompilation and in many cases a full Space restart is required to change the data schema.</p>
        <p>If the POJO model can't be replaced with the Document model, yet some level of schema evolution is desired within the POJO model, <a href="dynamic-properties.html">Dynamic Properties</a> can be used.</p>
        <h1><a name="type-definition"></a>Type Definition</h1>
        <p>Before beginning to write to and read from a<code>SpaceDocument</code> in the Space, an <span class="tc-bold">initial</span> schema definition of the document type is needed.</p>
        <p>For example, suppose we're implementing an electronic commerce system, and we need a type called <span class="tc-bold">Product</span> with the following properties:</p>
        <table style="width: 100%;" class="tc-standard">
            <col />
            <col />
            <thead>
                <tr>
                    <th>Product Property</th>
                    <th>Description</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>CatalogNumber </td>
                    <td>String</td>
                </tr>
                <tr>
                    <td>Category </td>
                    <td>String</td>
                </tr>
                <tr>
                    <td>Name </td>
                    <td>String</td>
                </tr>
                <tr>
                    <td>Description </td>
                    <td>String</td>
                </tr>
                <tr>
                    <td>Price </td>
                    <td>Float</td>
                </tr>
                <tr>
                    <td>Features </td>
                    <td>Nested document (for example: Manufacturer=Acme, RequiresAssembly=false, weight=7.5)</td>
                </tr>
                <tr>
                    <td>Tags </td>
                    <td>Collection of strings</td>
                </tr>
                <tr>
                    <td>Reviews </td>
                    <td>Collection of nested documents</td>
                </tr>
            </tbody>
        </table>
        <p>The  <code>CatalogNumber</code> property is the primary key, partitioning is done according to the <code>Category</code> property, and the <code>Name</code> and <code>Price</code> properties will be indexed because they are used in most of the queries executed. </p>
        <div class="tc-admon-tip">
            <p>Remember, the type definition is only for metadata; we're not concerned about fields like <code class="language-bash">Description</code> because they aren't used for indexing or any other metadata.</p>
        </div>
        <p>The following is an example of how to introduce a new Document type:</p>
        <div class="easyui-tabs" plain="true" data-options="">
            <div title="  Spring Namespace Configuration " style="padding:10px"><pre><code class="language-xml">&lt;os-core:embedded-space id="space" space-name="mySpace"  &gt;
      &lt;os-core:space-type type-name="Product" &gt;
        &lt;os-core:id property="CatalogNumber"/&gt;
        &lt;os-core:routing property="Category"/&gt;
        &lt;os-core:equal-index path="Name"/&gt;
        &lt;os-core:ordered-index path="Price"/&gt;
      &lt;/os-core:space-type&gt;
&lt;/os-core:embedded-space&gt;
&lt;os-core:giga-space id="gigaSpace" space="space"/&gt;
</code></pre>
            </div>
            <div title="  Plain Spring XML " style="padding:10px"><pre><code class="language-xml">&lt;bean id="space" class="org.openspaces.core.space.EmbeddedSpaceFactoryBean"&gt;
    &lt;property name="name" value="space" /&gt;
    &lt;property name="spaceTypes" &gt;
          &lt;list&gt;
        &lt;ref bean="productType"/&gt;
          &lt;/list&gt;
     &lt;/property&gt;
&lt;/bean&gt;
&lt;bean id="gigaSpace" class="org.openspaces.core.GigaSpaceFactoryBean"&gt;
    &lt;property name="space" ref="space"/&gt;
&lt;/bean&gt;

&lt;bean name="productType"
        class="org.openspaces.core.config.GigaSpaceDocumentTypeDescriptorFactoryBean"&gt;
        &lt;property name="typeName" value="Product"/&gt;
        &lt;property name="idProperty"&gt;
           &lt;bean class="org.openspaces.core.config.SpaceIdProperty"&gt;
             &lt;property name="propertyName" value="CatalogNumber"&gt;&lt;/property&gt;

           &lt;/bean&gt;
        &lt;/property&gt;
        &lt;property name="routingProperty"&gt;
           &lt;bean class="org.openspaces.core.config.SpaceRoutingProperty"&gt;
             &lt;property name="propertyName" value="Category"&gt;&lt;/property&gt;
           &lt;/bean&gt;
        &lt;/property&gt;
        &lt;property name="indexes"&gt;
             &lt;list&gt;
         &lt;bean class="org.openspaces.core.config.EqualIndex"&gt;
                   &lt;property name="path" value="Name"&gt;&lt;/property&gt;
                 &lt;/bean&gt;
                 &lt;bean class="org.openspaces.core.config.OrderedIndex"&gt;
                   &lt;property name="path" value="Price"&gt;&lt;/property&gt;
                 &lt;/bean&gt;
          &lt;/list&gt;
        &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
            </div>
            <div title="  Code " style="padding:10px"><pre><code class="language-java">public void registerProductType(GigaSpace gigaspace) {
    // Create type descriptor:
    SpaceTypeDescriptor typeDescriptor = new SpaceTypeDescriptorBuilder("Product")
        .idProperty("CatalogNumber")
        .routingProperty("Category")
        .addPropertyIndex("Name", SpaceIndexType.EQUAL)
        .addPropertyIndex("Price", SpaceIndexType.ORDERED)
        .create();
    // Register type:
    gigaspace.getTypeManager().registerTypeDescriptor(typeDescriptor);
}
</code></pre>
            </div>
        </div>
        <p>This code doesn't reflect the complete model, and most of the properties don't need to be introduced to the schema. Only properties with special roles (for example, <code>idProperty</code> and <code>routingProperty</code>) are part of the schema definition. These meta model settings <span class="tc-bold">can't be changed</span> without restarting the Space or dropping the type, clearing all its instances, and reintroducing it.</p>
        <div MadCap:conditions="Version.16-1-1-born">
            <p>&#160;</p>
            <h1><a name="Compound"></a>Compound SpaceId</h1>
            <p>Use the following techniques when defining a SpaceId from more than one property.</p>
            <div title="  Code " style="padding:10px"><pre><code class="language-java">List&lt;String&gt; idProperties = new ArrayList&lt;&gt;();
idProperties.add("firstName");
idProperties.add("lastName");
SpaceTypeDescriptor typeDescriptor = new SpaceTypeDescriptorBuilder("PersonDoc")
       .addFixedProperty("firstName", String.class)
       .addFixedProperty("lastName", String.class)
       .idProperty(idProperties)
       .create();

gigaSpace.getTypeManager().registerTypeDescriptor(typeDescriptor);

gigSpace.write(new SpaceDocument(typeName)
       .setProperty("firstName", "John")
       .setProperty("lastName", "Smith"));
</code></pre>
                <div title="  Code " style="padding:10px">
                    <h2>Space Routing</h2>
                    <p>The routing can be defined using only a single property, for example:</p><pre><code class="language-java">SpaceTypeDescriptorBuilder("PersonDoc")
	.routingProperty("firstName");
	...
</code></pre>
                    <h2>IdQuery Matching</h2>
                </div><pre><code class="language-java">Object id = CompoundSpaceId.from("John", "Smith");
gigaSpace.read(new IdQuery&lt;&gt;("PersonDoc", id));
gigaSpace.readById(new IdQuery&lt;&gt;("PersonDoc", id));
gigaSpace.readByIds(new IdQuery&lt;&gt;("PersonDoc", new Object[]{id1, id2};
));
</code></pre>
                <h2>Template Matching</h2><pre><code class="language-java">//exact match
SpaceDocument template = new SpaceDocument("PersonDoc")
       .setProperty("firstName", "John")
       .setProperty("lastName", "Smith");

gigaSpace.read(template);

//partial match
SpaceDocument template = new SpaceDocument("PersonDoc")
       .setProperty("firstName", "John");
gigaSpace.read(template);</code></pre>
                <h2>SQLQuery Matching</h2><pre>//exact matching
SQLQuery&lt;SpaceDocument&gt; query = new SQLQuery&lt;&gt;("PersonDoc", "firstName=? AND lastName=?");
       .setParameter(1, "John"))
       .setParameter(2, "Smith"));
gigaSpace.read(query);

//partial matching
SQLQuery&lt;SpaceDocument&gt; query = new SQLQuery&lt;&gt;("PersonDoc", "firstName=?", "John");
gigaSpace.read(query);
</pre>
            </div>
        </div>
        <h1 MadCap:conditions="Version.15-0-born">Querying with JDBC</h1>
        <p>SpaceDocuments don't have fixed schema, so each document can have a different set of properties. If you want to query documents via JDBC (either directly from the code or using tools such as Tableau or Apache Zeppelin), you must supply a schema so that the JDBC connection can infer metadata and execute queries. For example, executing a query like <code class="language-bash">SELECT * FROM Person</code> requires a schema that contains the set of columns.</p>
        <p>
            <p>A schema can be provided in one of the following ways: </p>
            <ul>
                <li>
                    <p><span class="tc-bold">Space type descriptor</span> (default) - When defining the type descriptor you can define fixed properties,  each of which will be included in the schema. However, each time you modify the schema you must restart the entire cluster because JDBC clients load the schema only once during initialization, so they have to be restarted to discover schema changes.</p>
                    <div class="tc-admon-note" MadCap:conditions="Version.16-2-died">
                        <p>In order to query <code>idProperty</code> and <code>routingProperty</code> using JDBC you must also define them as fixed properties, as <code>idProperty</code> is defined in the following example.</p>
                    </div>
                    <div class="tc-admon-note" MadCap:conditions="Version.16-2-born">
                        <p>In order to query <code>idProperty</code> and <code>routingProperty</code> using JDBC or when Tiered Storage is enabled you must also define them as fixed properties, as <code>idProperty </code>is defined in the following example.</p>
                        <p>You can use <code>addIdPropertyType()</code> or <code>addRoutingPropertyType()</code> respectively for specifying the property type. When id and routing are the same property, only set <code>addIdPropertyType()</code>.</p>
                    </div><pre><code> SpaceTypeDescriptor typeDescriptor = new SpaceTypeDescriptorBuilder("Product")        
.idProperty("id")
.addFixedProperty("name", String.class)
.addFixedProperty("price", Float.class)
.addFixedProperty("id", String.class).create();</code></pre>
                </li>
            </ul>
        </p>
        <ul>
            <li>
                <p><span class="tc-bold">External XML file</span> - You can define the schema in an XML file, and configure its location using the <code class="language-bash">jdbc-alt-schema-url</code> Space property. JDBC clients that connect to the Space can check whether this Space property is configured; if it is, the client then reads the schema from the XML file instead of from the Space type descriptor. This enables changing the schema definition during runtime without having to restart the Space. The XML file should be hosted in a location accessible to the clients, such as a web server. The <code>jdbc-alt-schema-url</code> property points to the XML file as one of the following:</p>
                <ul MadCap:conditions="Version.15-0-born">
                    <li>URL</li>
                    <li>Path on local disk</li>
                    <li><a href="web-jetty-processing-unit-container.html">Web Processing Unit</a>
                    </li>
                </ul>
                <p MadCap:conditions="Version.15-0-born">In this example, the property is set to a URL:</p><pre MadCap:conditions="Version.15-0-born"><code class="language-xml">&lt;os-core:space id="space" url="/./sql-test-space-alt?locators=localhost:4174"&gt;
    &lt;os-core:properties&gt;
        &lt;props&gt;
            &lt;prop key="jdbc-alt-schema-url"&gt;http://my-server/path/to/my-schema.xml&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/os-core:properties&gt;
&lt;/os-core:space&gt;</code></pre>
                <p MadCap:conditions="Version.15-0-born">In this example, the <span class="tc-bold">my-schema.xml</span> file defines the schema.</p><pre MadCap:conditions="Version.15-0-born"><code class="language-xml">&lt;my-schema&gt;
    &lt;table name="Purchase"&gt;
        &lt;column name="id" type="java.lang.String"/&gt;
        &lt;column name="name" type="java.lang.String"/&gt;
        &lt;column name="price" type="java.lang.Float"/&gt;
    &lt;/table&gt;
&lt;/my-schema&gt;</code></pre>
            </li>
        </ul>
        <h1><a name="creating-and-writing"></a>Creating and Writing Documents</h1>
        <p>To create a Document, create a <code>Map&lt;String,Object&gt;</code> with the requested properties, create a <code>SpaceDocument</code> object using the type name and properties, and write it to the Space using the regular <code>GigaSpace</code> write method:</p><pre><code class="language-java">public void writeProduct1(GigaSpace gigaspace) {
    // 1. Create the properties:
    Map&lt;String, Object&gt; properties = new HashMap&lt;String, Object&gt;();
    properties.put("CatalogNumber", "hw-1234");
    properties.put("Category", "Hardware");
    properties.put("Name", "Anvil");
    properties.put("Price", 9.99f);
    properties.put("Tags", new String[] {"heavy", "anvil"});

    Map&lt;String, Object&gt; features = new HashMap&lt;String, Object&gt;();
    features.put("Manufacturer", "Acme");
    features.put("RequiresAssembly", false);
    features.put("Weight", 100);
    properties.put("Features", features);

    Map&lt;String, Object&gt; review1 = new HashMap&lt;String, Object&gt;();
    review1.put("Name", "Wile E. Coyote");
    review1.put("Rate", 1);
    review1.put("Comments", "Don't drop this on your toe, it will hurt.");
    Map&lt;String, Object&gt; review2 = new HashMap&lt;String, Object&gt;();
    review2.put("Name", "Road Runner");
    review2.put("Rate", 5);
    review2.put("Comments", "Beep Beep!");
    properties.put("Reviews", new Map[] {review1, review2});

    // 2. Create the document using the type name and properties:
    SpaceDocument document = new SpaceDocument("Product", properties);
    // 3. Write the document to the space:
    gigaspace.write(document);
}
</code></pre>
        <p>Another way is to use the <code>DocumentProperties</code> class provided, which extends HashMap to provide fluent coding:</p><pre><code class="language-java">public void writeProduct2(GigaSpace gigaspace) {
    // 1. Create the properties:
    DocumentProperties properties = new DocumentProperties()
        .setProperty("CatalogNumber", "av-9876")
        .setProperty("Category", "Aviation")
        .setProperty("Name", "Jet Propelled Pogo Stick")
        .setProperty("Price", 19.99f)
        .setProperty("Tags", new String[] {"New", "Cool", "Pogo", "Jet"})
        .setProperty("Features", new DocumentProperties()
            .setProperty("Manufacturer", "Acme")
            .setProperty("RequiresAssembly", true)
            .setProperty("NumberOfParts", 42))
        .setProperty("Reviews", new DocumentProperties[] {
            new DocumentProperties()
                .setProperty("Name", "Wile E. Coyote")
                .setProperty("Rate", 1),
            new DocumentProperties()
                .setProperty("Name", "Road Runner")
                .setProperty("Rate", 5)});

    // 2. Create the document using the type name and properties:
    SpaceDocument document = new SpaceDocument("Product", properties);
    // 3. Write the document to the space:
    gigaspace.write(document);
}
</code></pre>
        <p>You can map JSON to and from a SpaceDocument with any parser. Here is an example:</p><pre><code class="language-java">package xap.sandbox.document;

import java.io.IOException;
import java.util.HashMap;

import org.codehaus.jackson.JsonGenerationException;
import org.codehaus.jackson.map.JsonMappingException;
import org.codehaus.jackson.map.ObjectMapper;
import org.openspaces.core.GigaSpace;
import org.openspaces.core.GigaSpaceConfigurer;
import org.openspaces.core.space.EmbeddedSpaceConfigurer;

import com.gigaspaces.document.SpaceDocument;
import com.gigaspaces.metadata.SpaceTypeDescriptor;
import com.gigaspaces.metadata.SpaceTypeDescriptorBuilder;
import com.gigaspaces.metadata.index.SpaceIndexType;
import com.j_spaces.core.client.SQLQuery;

public class ConvertJSONTODocument {

    @SuppressWarnings("unchecked")
    public static void main (String[] args) throws JsonGenerationException, JsonMappingException, IOException{
        
        GigaSpace gigaSpace = new GigaSpaceConfigurer(new EmbeddedSpaceConfigurer("mySpace")).gigaSpace();
        
        /****
         * We Need to Register a type by specifying a name, id, and routing field.
         * Routing is used to partition data across the grid, similar to a shard key 
         * This only needs to be done once 
         */
        final String PRODUCT_TYPE_NAME = "Product";

        SpaceTypeDescriptor typeDescriptor = new SpaceTypeDescriptorBuilder(PRODUCT_TYPE_NAME)
                    .idProperty("id")
                    .routingProperty("location")
                    .addPropertyIndex("processed", SpaceIndexType.EQUAL)
                    .create();

        gigaSpace.getTypeManager().registerTypeDescriptor(typeDescriptor);

        /****
         * Example JSON payload containing the properties 
         * of the new Type. In this example we use jaxson object mapper.
         * You can use any parser you would like
         */
        String jsonPayload = "{\"id\":1, \"location\":\"usa\", \"processed\":false}";

        HashMap&lt;String,Object&gt; jsonProperties =
                new ObjectMapper().readValue(jsonPayload, HashMap.class);

        /****
         * Convert to a space document simply pass the hash map to the 
         * in to the SpaceDocument Constructor along with the document type name
         * from above
         */
        SpaceDocument dataAsDocument = new SpaceDocument(PRODUCT_TYPE_NAME, jsonProperties);

        /***
         * Insert to the grid
         */
        gigaSpace.write(dataAsDocument);

        /***
         * To confirm the result. Read the document from the grid
         */
        SpaceDocument dataAsDocumentFromGrid = gigaSpace.read(new SQLQuery&lt;SpaceDocument&gt;(PRODUCT_TYPE_NAME, "id = ?", 1));

        /***
         * Map the Object back to JSON
         */
        String jsonFromGrid = new ObjectMapper().writeValueAsString(dataAsDocumentFromGrid);
        
        System.out.println(jsonFromGrid);
    }
}
</code></pre>
        <div class="tc-admon-note">
            <ul>
                <li>The <code>GigaSpace.writeMultiple</code> method can be used to write a batch of documents.</li>
                <li>Update semantics are the same as POJO, except <span class="tc-bold">partial update</span> that is not currently supported.</li>
                <li>Use only alphanumeric characters (a-z, A-Z, 0-9) and the underscore ("_") to construct property keys. Other characters might have special behavior in GigaSpaces (for example, "." is used to distinguish nested paths).</li>
            </ul>
        </div>
        <h1><a name="reading-and-removing"></a>Reading and Removing</h1>
        <p>There are three types of document queries, described in the following sections.</p>
        <h2><a name="template-query"></a>Template Query</h2>
        <p>This type of query uses a Space Document with <code>type</code> and any other set of properties values as a template for the query
For example: Read a document of type <code>Product</code> whose <code>Name</code> is <code>Anvil</code>:</p><pre><code class="language-java">public SpaceDocument readProductByTemplate(GigaSpace gigaSpace) {
    // Create template:
    SpaceDocument template = new SpaceDocument("Product");
    template.setProperty("Name", "Anvil");
    // Read:
    SpaceDocument result = gigaSpace.read(template);
    return result;
}
</code></pre>
        <h2><a name="sql-query"></a>SQL Query</h2>
        <p>You can use the <a href="query-sql.html">SQLQuery</a> to search for matching <code>SpaceDocument</code> entries.
For example: Read a document of type <code>Product</code> whose <code>Price</code> is greater than 15:</p><pre><code class="language-java">public SpaceDocument readProductBySQL(GigaSpace gigaSpace) {
    // Create query:
    SQLQuery&lt;SpaceDocument&gt; query =
        new SQLQuery&lt;SpaceDocument&gt;("Product", "Price &gt; ?");
    query.setParameter(1, 15f);
    // Read:
    SpaceDocument result = gigaSpace.read(query);
    return result;
}
</code></pre>
        <div class="tc-admon-note">
            <p>Consider indexing properties used in queries to boost performance.</p>
        </div>
        <p>Queries on nested properties are supported. For example, to read products manufactured by Acme:</p><pre><code class="language-java">public SpaceDocument[] readProductBySQLNested(GigaSpace gigaSpace) {
    // Create query:
    SQLQuery&lt;SpaceDocument&gt; query =
        new SQLQuery&lt;SpaceDocument&gt;("Product", "Features.Manufacturer = ?");
    query.setParameter(1, "Acme");
    // Read:
    SpaceDocument[] result = gigaSpace.readMultiple(query, 10);
    return result;
}
</code></pre>
        <h2><a name="id-based-query"></a>ID-Based Query</h2>
        <p>This code example shows how to read a document of type <code>Product</code> whose ID is <code>hw-1234</code>:</p><pre><code class="language-java">public SpaceDocument readProductById(GigaSpace gigaSpace) {
    return gigaSpace.readById(new IdQuery&lt;SpaceDocument&gt;("Product", "hw-1234"));
}
</code></pre>
        <p>Queries by multiple IDs are supported. For example:</p><pre><code class="language-java">public SpaceDocument[] readProductByMultipleIds(GigaSpace gigaSpace) {
    Object[] ids = new Object[] {"hw-1234", "av-9876"};
    ReadByIdsResult&lt;SpaceDocument&gt; result =
        gigaSpace.readByIds(new IdsQuery&lt;SpaceDocument&gt;("Product", ids));
    return result.getResultsArray();
}
</code></pre>
        <div class="tc-admon-note">
            <ul>
                <li>All other <code>GigaSpace</code> query operations (<code>readIfExists</code>, <code>readMultiple</code>, <code>take</code>, <code>takeIfExists</code>, <code>takeMultiple</code>, <code>count</code>, and <code>clear</code>) are also supported for documents entries.</li>
                <li>All other ID-based operations (<code>readIfExists</code>, <code>takeById</code>, <code>takeIfExistsById</code>, <code>takeByIds</code>) arealso supported for documents.</li>
                <li>All overloads of those operations with timeout, transactions, modifiers etc. are supported for documents. The semantics is similar to POJOs.</li>
            </ul>
        </div>
        <div class="tc-admon-important">
            <p>An ID-based query will not return results if the condition is on an auto-generated ID field <code>_spaceId</code> (generated for <code>spaceDocument</code>). Internal fields should not be queried because implementations are subject to change.</p>
        </div>
        <h1><a name="nested-properties"></a>Nested Properties</h1>
        <p>The <code>Document</code> properties values can be either scalars (integers, strings, enumerations, etc), collections (arrays, lists), or nested properties (Map or an extension of map, such as <code>DocumentProperties</code>). Values must adhere to the same restrictions as in the POJO model (e.g. be serializable). Nested properties can be queried by using the "." notation to describe paths, as shown above.</p>
        <div class="tc-admon-note">
            <p>It is highly recommended to use <code>DocumentProperties</code> for nested documents because it contains performance and memory footprint optimizations that are tailored for GigaSpaces usage.</p>
            <ul>
                <li>
                    <p>While it is possible to use  <code>SpaceDocument</code> as a property, it is probably a mistake, because it contains extra information that is not relevant for nested properties (type name, version, etc.).</p>
                </li>
                <li>
                    <p>Changing nested properties in an embedded Space is not safe.</p>
                </li>
            </ul>
        </div>
        <h1><a name="document-hierarchy"></a>Document Hierarchy</h1>
        <p>SpaceDocument query supports hierarchical relationships so that entries of a child are visible in the context of the parent document, but not the other way around. For example, a document with name <code>Employee</code>   can register its parent document <code>Person</code> in the following way:</p><pre><code class="language-java">SpaceTypeDescriptor employeeDescriptor = new SpaceTypeDescriptorBuilder(
                "Child Document Type Name", parentSpaceTypeDescriptor).create();
</code></pre>
        <p>Here is an example:</p>
        <div class="easyui-tabs" plain="true" data-options="">
            <div title=" Program" style="padding:10px"><pre><code class="language-java">    public static void main(String[] args) {

        // Create the Space
        GigaSpace space = new GigaSpaceConfigurer(new EmbeddedSpaceConfigurer(
                "mySpace")).gigaSpace();

        registerDocument(space);

        Map&lt;String, Object&gt; properties = new HashMap&lt;String, Object&gt;();
        properties.put("Id", "1234");
        properties.put("FirstName", "John");
        properties.put("LastName", "Fellner");

        SpaceDocument document1 = new SpaceDocument("Person", properties);

        space.write(document1);

        properties = new HashMap&lt;String, Object&gt;();
        properties.put("Id", "12345");
        properties.put("FirstName", "John");
        properties.put("LastName", "Walters");
        properties.put("employeeId", "1234");

        SpaceDocument document2 = new SpaceDocument("Employee", properties);

        space.write(document2);

        SQLQuery&lt;SpaceDocument&gt; query1 = new SQLQuery&lt;SpaceDocument&gt;(
                "Person", "");

        SpaceDocument[] result = space.readMultiple(query1);

        // You should see two documents
        System.out.println(result.length);

        SQLQuery&lt;SpaceDocument&gt; query2 = new SQLQuery&lt;SpaceDocument&gt;(
                "Employee", "");

        SpaceDocument[] result2 = space.readMultiple(query2);

        // You should see one document
        System.out.println(result2.length);

        System.exit(1);

    }
</code></pre>
            </div>
            <div title=" RegisterDocument" style="padding:10px"><pre><code class="language-java">    static public void registerDocument(GigaSpace space) {
        SpaceTypeDescriptor personDescriptor = new SpaceTypeDescriptorBuilder(
                "Person").idProperty("Id").create();
        // Register type:
        space.getTypeManager().registerTypeDescriptor(personDescriptor);

        SpaceTypeDescriptor employeeDescriptor = new SpaceTypeDescriptorBuilder(
                "Employee", personDescriptor).create();
        // Register type:
        space.getTypeManager().registerTypeDescriptor(employeeDescriptor);
    }
</code></pre>
            </div>
        </div>
        <h1><a name="indexing"></a>Indexing</h1>
        <p>Properties and nested paths can be <a href="indexing.html">indexed</a> to boost query performance. In the type registration sample above, the <code>Name</code> and <code>Price</code> properties are indexed.</p>
        <p>The schema is flexible and new properties may be added after the type has been registered, therefore it is possible to add indexes dynamically as well.</p>
        <div class="tc-admon-note">
            <p>For more information about indexing, see the <a href="indexing-overview.html">Indexing</a> page.</p>
        </div>
        <h1><a name="events"></a>Events</h1>
        <p>Event containers (both <a href="polling-container-overview.html">polling container</a> and <a href="notify-container-overview.html">notify container</a>) support Space <code>Document</code> entries.</p>
        <p>Here is a simple example of a polling event container configuration using a <code>Document</code>:</p>
        <div class="easyui-tabs" plain="true" data-options="">
            <div title="  Annotation " style="padding:10px"><pre><code class="language-xml">&lt;!-- Enable scan for OpenSpaces and Spring components --&gt;
&lt;context:component-scan base-package="com.mycompany"/&gt;

&lt;!-- Enable support for @Polling annotation --&gt;
&lt;os-events:annotation-support /&gt;

&lt;os-core:embedded-space id="space" space-name="mySpace"&gt;
      &lt;os-core:space-type type-name="Product" &gt;
        &lt;os-core:id property="CatalogNumber"/&gt;
        &lt;os-core:routing property="Category"/&gt;
        &lt;os-core:equal-index path="Name"/&gt;
        &lt;os-core:ordered-index path="Price"/&gt;
      &lt;/os-core:space-type&gt;
&lt;/os-core:embedded-space&gt;

&lt;os-core:giga-space id="gigaSpace" space="space"/&gt;
</code></pre><pre><code class="language-java">@EventDriven @Polling
public class SimpleListener {

    @EventTemplate
    SpaceDocument unprocessedData() {
        SpaceDocument template = new SpaceDocument("Product");
        template.setProperty("Name","Anvil");
        return template;
    }

    @SpaceDataEvent
    public SpaceDocument eventListener(SpaceDocument event) {
        //process Data here
    }
}
</code></pre>
            </div>
            <div title="  Namespace " style="padding:10px"><pre><code class="language-xml">&lt;os-core:embedded-space id="space" space-name="mySpace"&gt;
  &lt;os-core:space-type type-name="Product" &gt;
        &lt;os-core:id property="CatalogNumber"/&gt;
        &lt;os-core:routing property="Category"/&gt;
        &lt;os-core:equal-index path="Name"/&gt;
        &lt;os-core:ordered-index path="Price"/&gt;
      &lt;/os-core:space-type&gt;
&lt;/os-core:embedded-space&gt;

&lt;os-core:giga-space id="gigaSpace" space="space"/&gt;

&lt;bean id="simpleListener" class="SimpleListener" /&gt;

&lt;os-events:polling-container id="eventContainer" giga-space="gigaSpace"&gt;

    &lt;os-core:template&gt;
         &lt;bean class="com.gigaspaces.document.SpaceDocument"&gt;
                &lt;constructor-arg value="Product"/&gt;
                &lt;constructor-arg type="java.util.Map"&gt;
                    &lt;map&gt;
                        &lt;entry key="Name" value="Anvil" /&gt;
                    &lt;/map&gt;
                &lt;/constructor-arg&gt;
         &lt;/bean&gt;
    &lt;/os-core:template&gt;

    &lt;os-events:listener&gt;
        &lt;os-events:annotation-adapter&gt;
            &lt;os-events:delegate ref="simpleListener"/&gt;
        &lt;/os-events:annotation-adapter&gt;
    &lt;/os-events:listener&gt;
&lt;/os-events:polling-container&gt;
</code></pre>
            </div>
            <div title="  Plain XML " style="padding:10px"><pre><code class="language-xml">
&lt;bean id="space" class="org.openspaces.core.space.EmbeddedSpaceFactoryBean"&gt;
    &lt;property name="name" value="space" /&gt;
&lt;/bean&gt;

&lt;bean id="gigaSpace" class="org.openspaces.core.GigaSpaceFactoryBean"&gt;
    &lt;property name="space" ref="space" /&gt;
&lt;/bean&gt;

&lt;bean id="simpleListener" class="SimpleListener" /&gt;

&lt;bean id="eventContainer"
    class="org.openspaces.events.polling.SimplePollingEventListenerContainer"&gt;

    &lt;property name="gigaSpace" ref="gigaSpace" /&gt;

    &lt;property name="template"&gt;
        &lt;bean class="com.gigaspaces.document.SpaceDocument"&gt;
                &lt;constructor-arg value="Product"/&gt;
                &lt;constructor-arg type="java.util.Map"&gt;
                    &lt;map&gt;
                        &lt;entry key="Name" value="Anvil" /&gt;
                    &lt;/map&gt;
                &lt;/constructor-arg&gt;
         &lt;/bean&gt;
    &lt;/property&gt;

    &lt;property name="eventListener"&gt;
        &lt;bean class="org.openspaces.events.adapter.AnnotationEventListenerAdapter"&gt;
            &lt;property name="delegate" ref="simpleListener" /&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
            </div>
            <div title="  Code " style="padding:10px"><pre><code class="language-java">
GigaSpace gigaSpace = // either create the GigaSpace or get it by injection

SpaceDocument template = new SpaceDocument("Product");
template.setProperty("Name","Anvil");
SimplePollingEventListenerContainer pollingEventListenerContainer = new SimplePollingContainerConfigurer(gigaSpace)
                .template(template)
                .eventListenerAnnotation(new Object() {
                    @SpaceDataEvent
                    public void eventHappened() {
                        eventCalled.set(true);
                    }
                }).pollingContainer();

// when needed close the polling container
pollingEventListenerContainer.destroy();
</code></pre>
            </div>
        </div>
        <h1><a name="fifo"></a>FIFO Support</h1>
        <p><a href="fifo-support.html">FIFO support</a> is off by default with <code>Document</code> entries (same as with POJO). To enable FIFO support, modify the type introduction code and set the desired FIFO support mode. For example:</p>
        <div class="easyui-tabs" plain="true" data-options="">
            <div title="  Spring Namespace Configuration " style="padding:10px"><pre><code class="language-xml">&lt;os-core:embedded-space id="space" space-name="mySpace"&gt;
    &lt;os-core:space-type type-name="Product" fifo-support="OPERATION" &gt;
        &lt;!-- other properties definition --&gt;
    &lt;/os-core:space-type&gt;
&lt;/os-core:embedded-space&gt;
&lt;os-core:giga-space id="gigaSpace" space="space"/&gt;
</code></pre>
            </div>
            <div title="  Plain Spring XML " style="padding:10px"><pre><code class="language-xml">&lt;bean id="space" class="org.openspaces.core.space.EmbeddedSpaceFactoryBean"&gt;
    &lt;property name="name" value="space" /&gt;
    &lt;property name="spaceTypes" &gt;
          &lt;list&gt;
        &lt;ref bean="productType"/&gt;
          &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
&lt;bean id="gigaSpace" class="org.openspaces.core.GigaSpaceFactoryBean"&gt;
    &lt;property name="space" ref="space"/&gt;
&lt;/bean&gt;

&lt;bean name="productType"
        class="org.openspaces.core.config.GigaSpaceDocumentTypeDescriptorFactoryBean"&gt;
        &lt;property name="typeName" value="Product"/&gt;
        &lt;!-- other properties definition --&gt;
        &lt;property name="fifoSupport" value="OPERATION"/&gt;

&lt;/bean&gt;
</code></pre>
            </div>
            <div title="  Code " style="padding:10px"><pre><code class="language-java">// Create type descriptor:
SpaceTypeDescriptor typeDescriptor = new SpaceTypeDescriptorBuilder("Product")
    // Other type descriptor settings.
    .fifoSupport(FifoSupport.OPERATION)
    .create();
// Register type:
gigaspace.getTypeManager().registerTypeDescriptor(typeDescriptor);
</code></pre>
            </div>
        </div>
        <div class="tc-admon-note">
            <p>Changing FIFO support after a type has been registered is not supported</p>
            <p>For more information about FIFO, see the <a href="fifo-support.html">FIFO Support</a> page.</p>
        </div>
        <h1><a name="transactions-and-optimistic-locking"></a>Transactions and Optimistic Locking</h1>
        <p>Transactions and isolation modifiers semantics is identical to the POJO semantics. For more information about transactions, see the <a href="transaction-overview.html">Transaction Management</a> page.</p>
        <p>Optimistic locking is disabled by default with <code>Document</code> entries (same as with POJO). To enable it, modify the type introduction code and set the optimistic locking support. For example:</p>
        <div class="easyui-tabs" plain="true" data-options="">
            <div title="  Spring Namespace Configuration " style="padding:10px"><pre><code class="language-xml">&lt;os-core:embedded-space id="space" space-name="mySpace"&gt;
      &lt;os-core:space-type type-name="Product" optimistic-lock="true" &gt;
        &lt;!-- other properties definition --&gt;
      &lt;/os-core:space-type&gt;
&lt;/os-core:embedded-space&gt;
&lt;os-core:giga-space id="gigaSpace" space="space"/&gt;
</code></pre>
            </div>
            <div title="  Plain Spring XML " style="padding:10px"><pre><code class="language-xml">&lt;bean id="space" class="org.openspaces.core.space.EmbeddedSpaceFactoryBean"&gt;
    &lt;property name="name" value="space" /&gt;
    &lt;property name="spaceTypes" &gt;
          &lt;list&gt;
        &lt;ref bean="productType"/&gt;
          &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
&lt;bean id="gigaSpace" class="org.openspaces.core.GigaSpaceFactoryBean"&gt;
    &lt;property name="space" ref="space"/&gt;
&lt;/bean&gt;

&lt;bean name="productType"
        class="org.openspaces.core.config.GigaSpaceDocumentTypeDescriptorFactoryBean"&gt;
        &lt;property name="typeName" value="Product"/&gt;

        &lt;!-- other properties definition --&gt;
        &lt;property name="optimisticLock" value="true"/&gt;
&lt;/bean&gt;
</code></pre>
            </div>
            <div title="  Code " style="padding:10px"><pre><code class="language-java">// Create type descriptor:
SpaceTypeDescriptor typeDescriptor = new SpaceTypeDescriptorBuilder("Product")
    // Other type descriptor settings.
    .supportsOptimisticLocking(true)
    .create();
// Register type:
gigaspace.getTypeManager().registerTypeDescriptor(typeDescriptor);
</code></pre>
            </div>
        </div>
        <div class="tc-admon-note">
            <p>Changing optimistic locking after a type has been registered is not supported.</p>
            <p>For more information about optimistic locking, see the <a href="transaction-optimistic-locking.html">Optimistic Locking</a> page.</p>
        </div>
        <h1><a name="local-cache-local-view"></a>Local Cache / Local View</h1>
        <p><a href="local-view.html">Local View</a> and <a href="local-cache.html">Local Cache</a> are supported for Documents. By default, the <code>SpaceDocument</code> instance is stored in the cache which speeds up query performance since the data does not need to be transformed from internal structure to <code>SpaceDocument</code>.</p>
        <p>If you intend to use local cache or local view in a mixed POJO-Document environment, please refer to <a href="document-pojo-interoperability.html">Document-POJO Interoperability</a>.</p>
        <h1><a name="persistency"></a>Persistency</h1>
        <p>External Data Source is supported for space documents.
Example on how to implement an EDS that persists <code>SpaceDocuments</code> of type <code>Trade</code>:</p>
        <div class="easyui-tabs" plain="true" data-options="">
            <div title="  Configuration " style="padding:10px"><pre><code class="language-xml">&lt;bean id="documentDataSource" class="com.test.DocumentEDS"/&gt;

&lt;os-core:embedded-space id="space" space-name="mySpace" schema="persistent" external-data-source="documentDataSource"&gt;
    &lt;os-core:space-type type-name="Trade" &gt;
       &lt;os-core:id property="uid" auto-generate="true"/&gt;
       &lt;os-core:routing property="symbolLabel"/&gt;
    &lt;/os-core:space-type&gt;
    &lt;os-core:properties&gt;
        &lt;props&gt;
            &lt;prop key="space-config.external-data-source.data-class"&gt;com.gigaspaces.document.SpaceDocument&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/os-core:properties&gt;
&lt;/os-core:embedded-space&gt;
</code></pre>
            </div>
            <div title="  The EDS Implementation " style="padding:10px"><pre><code class="language-java">package com.test;

public class DocumentEDS
        implements ManagedDataSource&lt;SpaceDocument&gt;, BulkDataPersister
{

    public void init(Properties prop) throws DataSourceException
    {
        // initialize persistency layer
    }

    public DataIterator&lt;SpaceDocument&gt; initialLoad() throws DataSourceException
    {
        // load all the data from persistency
        // build and return an iterator of documents
    }

    public void executeBulk(List&lt;BulkItem&gt; bulk) throws DataSourceException
    {
        for (BulkItem bulkItem : bulk)
        {
            SpaceDocument document = (SpaceDocument) bulkItem.getItem();

            switch (bulkItem.getOperation())
            {
                case BulkItem.WRITE:

                   // writeDocument(document);
                    break;
                case BulkItem.UPDATE:

                   // updateDocument(document, bulkItem.getIdPropertyName());
                    break;
                case BulkItem.REMOVE:
                    //removeDocument(document, bulkItem.getIdPropertyName());

                    break;

                default:
                    break;
            }
        }
    }

    public void shutdown() throws DataSourceException
    {
        //cleanup resources and close the persistency
    }

}
</code></pre>
            </div>
        </div>
        <p>Different document databases can be used to implement the document persistency, such as MongoDB and CouchDB.
POJOs can be persisted via document EDS as well, in the same way.</p>
        <div class="tc-admon-note">
            <ul>
                <li>In order to support <code>initialLoad</code> of documents the relevant types must be declared in the Space bean, so that they are registered in the space before <code>initialLoad</code> is invoked.</li>
                <li>Document persistence is currently not provided by default - If needed, an External Data Source should be implemented to fit the required solution.</li>
            </ul>
        </div>
        <h2><a name="transient-document"></a>Transient Documents</h2>
        <p>When using a persistent Space, there are situations where not all Space Documents need to be persisted. You can specify a document as transient by invoking the <code>setTransient()</code> method.</p><pre><code class="language-java">   SpaceDocument doc = new SpaceDocument("Entity");
   ......       
   doc.setTransient(true);
</code></pre>
        <h1><a name="space-filters"></a>Space Filters</h1>
        <p>Space Filters are supported for Space Documents.</p>
        <div class="tc-admon-note">
            <p>If you intend to use Space filters in a mixed POJO-Document environment, see the <a href="document-pojo-interoperability.html">Interoperability</a> page.</p>
        </div>
        <h1><a name="replication-filters"></a>Replication Filters</h1>
        <p>Space Replication Filters are supported for Space Documents.</p>
        <div class="tc-admon-note">
            <p>If you intend to use Space replication filters in a mixed POJO-Document environment, see the <a href="document-pojo-interoperability.html">Interoperability</a> page. </p>
        </div>
    </body>
</html>