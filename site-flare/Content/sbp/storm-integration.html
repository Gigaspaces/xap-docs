<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
<head></head>
<body>
<h1>XAP Integration with Storm</h1>
  

<table>
<thead>
<tr>
<th>Author</th>
<th>XAP Version</th>
<th>Last Updated</th>
<th>Reference</th>
<th>Download</th>
</tr>
</thead>

<tbody>
<tr>
<td>Oleksiy Dyagilev</td>
<td>10.0</td>
<td>August 2014</td>
<td><a href="https://storm.incubator.apache.org">Storm</a></td>
<td><a href="https://github.com/fe2s/xap-storm">Github link</a></td>
</tr>
</tbody>
</table>

<h1><a name="introduction">&#160;</a>Introduction</h1>

<p>Real-time processing is becoming very popular, and Storm is a popular open source framework and runtime used by Twitter for processing real-time data streams.  Storm addresses the complexity of running real time streams through a compute cluster by providing an elegant set of abstractions that make it easier to reason about your problem domain by letting you focus on data flows rather than on implementation details.</p>

<p>Storm has many use cases: realtime analytics, online machine learning, continuous computation, distributed RPC, ETL, and more. Storm is fast: a benchmark clocked it at over a million tuples processed per second per node. It is scalable, fault-tolerant, guarantees your data will be processed, and is easy to set up and operate.</p>

<table class="tc-borderless"><tr><td style="width:70%;"><p>This pattern integrates XAP with Storm. XAP is used as stream data source and fast reliable persistent storage, whereas Storm is in charge of data processing. We support both pure Storm and Trident framework.</p>

<p>As part of this integration we provide classic <span class="tc-bold">Word Counter</span> and <span class="tc-bold">Twitter Reach</span> implementations on top of XAP and Trident.</p>

<p>Also, we demonstrate how to build highly available, scalable equivalent of <span class="tc-bold">Realtime Google Analytics</span> application with XAP and Storm. Application can be deployed to cloud with one click using Cloudify.</p>
</td>
<td style="width:30%;"><p><MadCap:snippetBlock src="Resources/Snippets/YouTube.flsnp" MadCap:snippetVariables="Links.YouTube:https://www.youtube.com/watch?v=c9L06fKbbW8," /></p>
</td>
</tr></table>

<h1><a name="storm-in-a-nutshell">&#160;</a>Storm in a Nutshell</h1>

<p>Storm is a real time, open source data streaming framework that functions entirely in memory.  It constructs a processing graph that feeds data from an input source through processing nodes.  The processing graph is called a "topology".  The input data sources are called "spouts", and the processing nodes are called "bolts".  The data model consists of tuples.  Tuples flow from Spouts to the bolts, which execute user code. Besides simply being locations where data is transformed or accumulated, bolts can also join streams and branch streams.</p>

<p>Storm is designed to be run on several machines to provide parallelism.  Storm topologies are deployed in a manner somewhat similar to a webapp or a XAP processing unit; a jar file is presented to a deployer which distributes it around the cluster where it is loaded and executed.  A topology runs until it is terminated.</p>

<div class="tc-align-center"><p><img src="/attachment_files/storm/storm-nutshell.png" alt="alt tag" /></p>
</div>

<p>Beside Storm, there is a <span class="tc-bold">Trident</span> - a high-level abstraction for doing realtime computing on top of Storm. Trident adds primitives like groupBy, filter, merge, aggregation to simplify common computation routines. Trident has consistent, exactly-once semantics, so it is easy to reason about Trident topologies.</p>

<p>Capability to guarantee exactly-once semantics comes with additional cost. To guarantee that, incremental processing should be done on top of persistence data source. Trident has to ensure that all updates are idempotent. Usually that leads to lower throughput and higher latency than similar topology with pure Storm.</p>

<h1><a name="spouts">&#160;</a>Spouts</h1>

<p>Basically, Spouts provide the source of tuples for Storm processing.  For spouts to be maximally performant and reliable, they need to provide tuples in batches, and be able to replay failed batches when necessary.  Of course, in order to have batches, you need storage, and to be able to replay batches, you need reliable storage.  XAP is about the highest performing, reliable source of data out there, so a spout that serves tuples from XAP is a natural combination.</p>

<div class="tc-align-center"><p><img src="/attachment_files/storm/xap-general-spout.png" alt="alt tag" /></p>
</div>

<p>Depending on domain model and level of guarantees you want to provide, you choose either pure Storm or Trident. We provide Spout implementations for both - <code>XAPSimpleSpout</code> and <code>XAPTranscationalTridentSpout</code> respectively.</p>

<h2><a name="storm-spout">&#160;</a>Storm Spout</h2>

<p><code>XAPSimpleSpout</code> is a spout implementation for pure Storm that reads data in batches from XAP. On XAP side we introduce conception of stream. Please find <code>SimpleStream</code> - a stream implementation that supports writing data in single and batch modes and reading in batch mode. <code>SimpleStream</code> leverages XAP's FIFO(First In, First Out) capabilities.</p>

<div class="tc-align-center"><p><img src="/attachment_files/storm/simple-spout.png" alt="alt tag" /></p>
</div>

<p><code>SimpleStream</code> works with arbitrary space class that has <code>FifoSupport.OPERATION</code> annotation and implements <code>Serializable</code>.</p>

<p>Here is an example how one may write data to <code>SimpleStream</code> and process it in Storm topology. Let's consider we would like to build an application to analyze the stream of page views (user clicks) on website. At first, we create a data model that represents a page view</p>

<pre><code class="language-java"> @SpaceClass(fifoSupport = FifoSupport.OPERATION)
 public class PageView implements Serializable {
     private String id;
     private String page;
    private String sessionId;
    [getters setters omitted for brevity]
 }
</code></pre>

<p>Now we would like to create a reference to stream instance and write some data.</p>

<pre><code class="language-java"> SimpleStream&lt;PageView&gt; stream = new SimpleStream&lt;&gt;(space, new PageView());
 stream.writeBatch(pageViews);
</code></pre>

<p>The second argument of <code>SimpleStream</code> is a template used to match objects during reading.
If you want to have several streams with the same type, template objects should differentiate your streams.</p>

<p>Now let's create a spout for <code>PageView</code> stream.</p>

<pre><code class="language-java"> public class PageViewSpout extends XAPSimpleSpout&lt;PageView&gt; {
     public PageViewSpout() {
         super(new PageViewTupleConverter(), new PageView());
     }
 }
</code></pre>

<p>To create a spout, we have to specify how we want our space class be converted to Storm tuple. That is exactly what <code>TupleConverter</code> knows about.</p>

<pre><code class="language-java"> class PageViewTupleConverter implements TupleConverter&lt;PageView&gt; {
     @Override
     public Fields tupleFields() {
         return new Fields("page", "session");
     }

     @Override
     public List&lt;Object&gt; spaceObjectToTuple(PageView pageView) {
         return Arrays.&lt;Object&gt;asList(pageView.getPage(), pageView.getSessionId());
     }
 }
</code></pre>

<p>At this point we have everything ready to build Storm topology with <code>PageViewSpout</code>.</p>

<pre><code class="language-java"> Config conf = new Config();
 conf.put(ConfigConstants.XAP_SPACE_URL_KEY, "jini://*/*/space");
 conf.put(ConfigConstants. XAP_STREAM_BATCH_SIZE, 300);
 TopologyBuilder builder = new TopologyBuilder();
 builder.setSpout("pageViewSpout", new PageViewSpout());
</code></pre>

<p><code>ConfigConstants.XAP_SPACE_URL_KEY</code> is a space URL</p>

<p><code>ConfigConstants. XAP_STREAM_BATCH_SIZE</code> is a maximum number of items that spout reads from XAP with one hit.</p>

<h2><a name="trident-spout">&#160;</a>Trident Spout</h2>

<p><code>XAPTranscationalTridentSpout</code> is a scalable, fault-tolerant, transactional spout for Trident, supports pipelining. Let's discuss all its properties in details.</p>

<p>For spout to be maximally performant, we want an ability to scale the number of instances to control the parallelism of reader threads.</p>

<p>There are several spout APIs available that we could potentially use for our XAPTranscationalTridentSpout implementation:
- <code>IPartitionedTridentSpout</code>: A transactional spout that reads from a partitioned data source. The problem with this API is that it doesn't acknowledge when batch is successfully processed which is critical for in memory solutions since we want to remove items from the grid as soon as they have been processed. Another option would be to use XAP's lease capability to remove items by time out. This might be unsafe, if we keep items too long, we might consume all available memory.
- <code>ITridentSpout</code>: The most general API. Setting parallelism hint for this spout to N will create N spout instances, single coordinator and N emitters. When coordinator issues new transaction id, it passes this id to all emitters. Emitter reads its portion of transaction by given transaction id. Merged data from all emitters forms transaction.</p>

<p>For our implementation we choose <code>ITridentSpout</code> API.</p>

<p><img src="/attachment_files/storm/trident-spout.png" alt="alt tag" /></p>

<p>There is one to one mapping between XAP partitions and emitters.</p>

<p>Storm framework guarantees that topology is high available, if some component fails, it restarts it. That means our spout implementation should be stateless or able to recover its state after failure.</p>

<p>When emitter is created, it calls remote service <code>ConsumerRegistryService</code> to register itself. <code>ConsumerRegistryService</code> knows the number of XAP partitions and keeps track of the last allocated partition.  This information is reliably stored in the space, see <code>ConsumerRegistry.java</code>.</p>

<div class="tc-align-center"><p><img src="/attachment_files/storm/consumer-registry.png" alt="alt tag" /></p>
</div>

<p>Remember that parallelism hint for <code>XAPTranscationalTridentSpout</code> should equal to the number of XAP partitions.</p>

<p>The property of being transactional is defined in Trident as following:
- batches for a given txid are always the same. Replays of batches for a txid will exact same set of tuples as the first time that batch was emitted for that txid.
- there's no overlap between batches of tuples (tuples are in one batch or another, never multiple).
- every tuple is in a batch (no tuples are skipped)</p>

<p><code>XAPTranscationalTridentSpout</code> works with <code>PartitionedStream</code> that wraps stream elements into Item class and keeps items ordered by "offset' property. There is one <code>PartitionStream</code> instance per XAP partition.</p>

<div class="tc-align-center"><p><img src="/attachment_files/storm/partitioned-stream.png" alt="alt tag" /></p>
</div>

<p>Stream's <code>WriterHead</code> holds the last offset in the stream.  Any time batch of elements (or single element) written to stream, <code>WriterHead</code> incremented by the number of elements. Allocated numbers used to populate offset property of Items. <code>WriterHead</code> object is kept in heap, there is no need to keep it in space. If primary partition fails, <code>WriterHead</code> is reinitialized to be the max offset value for given stream.</p>

<p><code>ReaderHead</code> points to the last read item. We have to keep this value in the space, otherwise if partition fails we won't be able to infer this value.</p>

<p>When spout request new batch, we take <code>ReaderHead</code>, read data from that point and update <code>ReaderHead</code>. New <code>BatchMetadata</code> object is placed to the space, it keeps start offset and number of items in the batch. In case Storm requests transaction replaying, we are able to reread exactly the same items by given batchId. Finally, once Storm acknowledges that batch successfully processed, we delete <code>BatchMetadata</code> and corresponding items from the spac</p>

</body>
</html>