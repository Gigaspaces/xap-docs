<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
<head></head>
<body>
<h1>Trading Settlement</h1>
  

<table>
<thead>
<tr>
<th>Author</th>
<th>XAP Version</th>
<th>Last Updated</th>
<th>Reference</th>
<th>Download</th>
</tr>
</thead>

<tbody>
<tr>
<td>Shay Hassidim</td>
<td>8.0.4</td>
<td>Nov 2011</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

<h1><a name="overview">&#160;</a>Overview</h1>

<p>This is a demo of a trading settlement system.  Settlement occurs after a trade, and involves the delivery of securities for payment between one party and another.  Because the demo operates in real-time, it can be expanded to provide risk management or be integrated with a rules engine for complex event processing (CEP).</p>

<p>Due to the speed at which markets move today, reliable risk assessment requires the ability to analyze trades and their impact on a portfolio in as close to real-time as possible.  In addition, having a <a href="http://en.wikipedia.org/wiki/Straight-through_processing">straight-through processing</a> capability provides major benefits for risk and cost reduction. This demo illustrates how such minimum-latency systems can be built and we do so with the entire tier-based architecture built on GigaSpaces, including the following components:</p>

<ul>
<li>Data tier</li>
<li>Business logic execution tier</li>
<li>Messaging tier</li>
<li>Web tier</li>
<li>Database persistence tier</li>
</ul>

<p>It is designed to be real-time, mission-critical and provide:</p>

<ul>
<li>Scalability</li>
<li>Elasticity</li>
<li>High availability</li>
<li>Low latency</li>
</ul>

<p>The following GigaSpaces features are utilized:</p>

<ul>
<li>Remoting</li>
<li>Events</li>
<li>Event Processing</li>
<li>Asynchronous persistency</li>
<li>Transparent HTTP session clustering</li>
<li>Elastic Processing Unit</li>
<li>Document API</li>
</ul>

<h1><a name="architecture">&#160;</a>Architecture</h1>

<p>Blotter clients connect to the servlet through HTTP.  The blotter displays user trades, counter-party trades and matched deals.  It is also used to control the feeder.</p>

<p>The feeder generates random trade objects and places them into the space.</p>

<p>The <a href="/product_overview/terminology.html">grid topology</a> for the event processing engine consists of 2 partitions with backup instances.</p>

<p>It receives an event when an unprocessed trade is placed in the space and starts a transaction.  The transaction consists of several operations:</p>

<ul>
<li>For an unprocessed trade, query the space to see if there is a matching trade.</li>
<li>If a matching trade is found, create a deal object and write it to the space.  Set the matched flag for both the unprocessed trade and the matching trade to true.</li>
<li>Set the unprocessed trade to processed.</li>
</ul>

<p>The messaging processor receives events when deals are matched and generates an XML message with the deal specifics.  These messages can be sent to external systems.</p>

<p>The monitor is a thread that periodically counts the number of matched deal objects in the space.  If this number exceeds 50, it will scale the grid up.  The grid will be scaled down if this number falls below 50.</p>

<p>The <a href="/xap/14.0/dev-java/asynchronous-persistency-with-the-mirror.html">mirror service</a> provides reliable asynchronous persistence to a HSQL database through a hibernate interface.</p>

<p><img src="/attachment_files/sbp/SA-Architecture.png" alt="SA-Architecture.png" /></p>

<h1><a name="processing-unit-relationships-and-events">&#160;</a>Processing Unit Relationships and Events</h1>

<p>The feeder, web servlet, monitor, messaging and mirror are deployed as <a href="a-typical-sba-application.html">Processing Units (PUs)</a>.</p>

<p>The event processing engine is deployed as an <a href="/xap/14.0/dev-java/elastic-processing-unit-overview.html"><span class="tc-italic">Elastic</span> PU</a> with <a href="/xap/14.0/admin/replication.html">replication</a>.  The elasticity enables the grid to scale up or down based on user-defined metrics.  In this case, we use the number of trade objects in the space, which is counted by the monitor PU.  When this exceeds 50, memory capacity is increased through the <a href="/xap/14.0/security/administration-and-monitoring-api-security.html">admin API</a>.  This causes new <a href="/product_overview/service-grid.html#gsc">processing containers</a> to be provisioned and the Elastic PUs to be rebalanced across the new nodes.  Scaling down is the reverse process.</p>

<p>You can step through the demo code in your favorite IDE by deploying the target processing unit(s) in an <a href="/xap/14.0/dev-java/deploying-and-running-the-processing-unit.html">Integrated Processing Unit Container</a>.</p>

<p>Deal matching uses a <a href="/xap/14.0/dev-java/polling-container.html">polling container</a> and <a href="/xap/14.0/dev-java/transaction-management.html">transactions</a>.</p>

<p><img src="/attachment_files/sbp/SA-PUs.png" alt="SA-PUs.png" /></p>

<h1><a name="key-features">&#160;</a>Key Features</h1>

<h2><a name="event-processing-for-trade-matching">&#160;</a>Event Processing for Trade Matching</h2>

<p>Trade matching for deals is based on the following fields: trading party, counter-party, instrument, matched flag, and buy/sell flag.  A polling container receives an event for each unprocessed trade in the space, and the matching process is done by transaction.</p>

<pre><code class="language-java">@EventDriven @Polling(gigaSpace = "gigaSpace") @TransactionalEvent(transactionManager="transactionManager")
public class TradeMatchingProcessor {
    @EventTemplate
    public SQLQuery&lt;Trade&gt; getUnprocessedTrade() {
        SQLQuery&lt;Trade&gt; template = new SQLQuery&lt;Trade&gt;(Trade.class, "processed = false");
        return template;
    }
    @SpaceDataEvent
    public Trade onEvent(Trade trade) throws Exception {
        SQLQuery&lt;Trade&gt; template =
            new SQLQuery&lt;Trade&gt;(Trade.class, "instrument = '" + trade.getInstrument() +
                    "' and counterparty = '" + trade.getTradingParty() +
                    "' and tradingParty = '" + trade.getCounterparty() +
                    "' and matched = false and  buySellFlag = " +
                    (trade.getBuySellFlag().equals("B") ? "'S'" : "'B'"));

        Trade[] matchingTrades = gigaSpace.readMultiple(template, Integer.MAX_VALUE);
        trade.setProcessed(true);
        return trade;
    }
</code></pre>

<h2><a name="data-partitioning">&#160;</a>Data Partitioning</h2>

<p>In a partitioned space, data is routed to a particular partition based on a routing property.  Here we use a hash based on the trading party and counter-party.  This provides data affinity so that trades between these parties are located in the same space, which minimizes latency.</p>

<pre><code class="language-java">@SpaceClass
public class Trade implements Serializable {
...
@SpaceRouting
public String getRouting() {
    if (tradingParty == null) {
        return null;
    }
    String[] entities = new String[] {tradingParty,counterparty};
    Arrays.sort(entities);
    routing = entities[0] + "-" + entities[1];
    return routing;
}
}
</code></pre>

<h2><a name="scaling-the-elastic-processing-unit-epu">&#160;</a>Scaling the Elastic Processing Unit (EPU)</h2>

<p>When the number of trade objects in the space equals 50, the memory available for processing containers is increased from 128MB to 256MB.</p>

<pre><code class="language-java">pu = admin.getProcessingUnits().waitFor("settlement-app-components", 5,TimeUnit.SECONDS);
pu.scale(new ManualCapacityScaleConfigurer()
        .memoryCapacity(TARGET_MEMEORY_CAPACITY_MB_SCALED_UP,MemoryUnit.MEGABYTES)
        .create());
        );
</code></pre>

<p>Click <a href="/xap/14.0/dev-java/elastic-processing-unit-overview.html#ElasticProcessingUnit-MaximumMemoryCapacity">here</a> to see how the number of processing containers is dynamically calculated based on the amount of memory.</p>

<h2><a name="space-document">&#160;</a>Space Document</h2>

<p>A <a href="/xap/14.0/dev-java/document-api.html">document store</a> is used for saving matched deals.  This document contains the following items:</p>

<ul>
<li>Deal ID</li>
<li>Routing string</li>
<li>Buy-side party</li>
<li>Sell-side party</li>
<li>MatchedDeal object</li>
</ul>

<p>The document properties are <span class="tc-italic">get</span> and <span class="tc-italic">set</span> with code like this:</p>

<pre><code class="language-java">public class MatchedDeal extends SpaceDocument {
    public String getDealId() {
        return getProperty("DealId");
    }

    public MatchedDeal setDealId(String dealId) {
        setProperty("DealId", dealId);
        return this;
    }
    ...
}
</code></pre>

<h2><a name="data-access-object-dao">&#160;</a>Data Access Object (DAO)</h2>

<p>The below interface defines how to interact with the space.</p>

<pre><code class="language-java">public interface SettlementAppDAO {
    MatchedDeal[] getMatchedDeals(String entity);

    MatchedDeal[] getMatchedDeals(String entity, String counterparty);

    Trade[] getTrades(String entity, String counterparty);

    SpaceDocument saveDocument(SpaceDocument document);

    Trade saveTrade(Trade trade);

    Trade[] getCounterpartyTrades(String entity, String counterparty);

    void clearUnmatchedTrades();
}
</code></pre>

<h2><a name="database-table-mapping">&#160;</a>Database Table Mapping</h2>

<p>The trade and matched deal objects are persisted to the HSQL database through Hibernate.  An example of the Hibernate mapping is below.</p>

<pre><code class="language-java">&lt;hibernate-mapping&gt;
    &lt;class
        name="com.gigaspaces.settlement.model.Trade"
        table="TRADE"
        mutable="true"&gt;

        &lt;id
            name="tradeId"
            column="TRADE_ID"
            type="java.lang.String"&gt;

            &lt;generator class="assigned"&gt;
    &lt;/generator&gt;
        &lt;/id&gt;

        &lt;property
            name="tradingParty"
            type="java.lang.String"
            update="true"
            insert="true"
            column="trading_party"
        /&gt;

............
</code></pre>

<h2><a name="web-session-management">&#160;</a>Web Session Management</h2>

<p>HTTP Sessions are maintained in the space and a copy is also kept in a <a href="/xap/14.0/dev-java/client-side-caching.html">local cache</a>, with 1 object per client.  Sessions are accessed using the following:</p>

<pre><code class="language-java">jetty.sessions.spaceUrl=jini://*/*/settlementSpace?useLocalCache
</code></pre>

<h1><a name="running-the-demo">&#160;</a>Running the Demo</h1>

<ol>
<li><span class="tc-bold">Download</span> the <a href="/attachment_files/sbp/TradingSettlement.zip">TradingSettlement.zip</a> file and <span class="tc-bold">extract</span> it into an empty folder.</li>
<li><span class="tc-bold">Move</span> into the settlement-app folder.</li>
<li><span class="tc-bold">Rename</span> the files ending in <span class="tc-bold">.at</span> to <span class="tc-bold">.bat</span>.</li>
<li><span class="tc-bold">Edit</span> setExampleEnv.bat and change JAVA_HOME and JSHOMEDIR.</li>
<li><span class="tc-bold">Add</span> \gigaspaces-xap-premium-8.0.4-ga\tools\maven\apache-maven-3.0.2\bin to you <span class="tc-bold">path</span>.</li>
<li><span class="tc-bold">Run</span> \gigaspaces-xap-premium-8.0.4-ga\tools\maven\installmavenrep.bat.</li>
<li><span class="tc-bold">Build</span> the demo by <span class="tc-bold">running</span> the following command:  mvn package</li>

<li><p><span class="tc-bold">Execute</span> the demo by running the start and deploy scripts in the following order:</p>

<ul>
<li><span class="tc-bold">gs-agent-esm.bat</span>: starts the GigaSpaces agent in elastic deployment mode</li>
<li><span class="tc-bold">gs-ui.bat</span>: starts the GigaSpaces user interface</li>
<li><span class="tc-bold">start-hsqldb.bat</span>: starts the HSQL database</li>
<li><span class="tc-bold">start-DatabaseManager.bat</span>: starts the HSQL database manager</li>
<li><span class="tc-bold">deploy-app.bat</span></li>
<li><span class="tc-bold">deploy-messaging.bat</span></li>
<li><span class="tc-bold">deploy-feeder.bat</span></li>
<li><span class="tc-bold">deploy-monitor.bat</span></li>
<li><span class="tc-bold">deploy-mirror.bat</span></li>
<li><span class="tc-bold">deploy-blotter.bat</span> (could take up to 10 minutes to deploy)</li>
</ul></li>

<li><p><span class="tc-bold">Connect</span> to the blotter (gwt-dealsBlotter processing unit) using your browser <code>http://127.0.0.1:8080/gwt-dealsBlotter/</code>.</p></li>

<li><p><span class="tc-bold">Log in</span> with username that matches this format:  <any characters>@<trading entity> where <trading entity> = bank1 or cust1 or bank2 or cust2, etc.  For example, username = 123@bank1.  Password can be any characters.</p></li>

<li><p><span class="tc-bold">Start</span> the application by clicking on the Administration tab and then clicking Start Feeder. You can Speed up the feeder rate by decreasing the refresh Interval to 1000 and clicking the Start Feeder.</p></li>

<li><p>When the number of com.gigaspaces.settlement.model.Trade object &gt; 50 (use the GS-UI - Data Type List for the settlementSpace to see the amount of objects), the settlementSpace will scale up by creating 2 additional GSCs. See the Hosts view.</p></li>

<li><p>You can scale the application down by clicking on the Administration tab and then clicking on Clear Trades.</p></li>
</ol>

</body>
</html>