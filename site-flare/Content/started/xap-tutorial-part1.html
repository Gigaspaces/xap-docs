<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
    <head>
    </head>
    <body>
        <h1>Interacting with the Space</h1>
        <p>In this part of the tutorial we will demonstrate how to create a space and how you can interact with it. We will also demonstrate how you can improve your space search performance by using indexes and returning partial results.</p>
        <h1><a name="creating-a-space"></a>Creating a Space</h1>
        <p>Let's create a space called "xapTutorialSpace' that is co-located within an application. This type of space is called embedded space.</p>
        <p>Here is an example how you start an embedded space:</p><pre><code class="language-java">// Create the Space
GigaSpace gigaSpace = new GigaSpaceConfigurer(new EmbeddedSpaceConfigurer("xapTutorialSpace")).gigaSpace();
</code></pre>
        <p>This space we just created can also be accessed remotely from another JVM by connecting with a <code>SpaceProxyConfigurer</code>. In order to do so you would use the following code:</p><pre><code class="language-java">GigaSpace gigaSpace = new GigaSpaceConfigurer(new SpaceProxyConfigurer("xapTutorialSpace")).gigaSpace();
</code></pre>
        <p>You can configure the Space connection with several options.</p>
        <div class="tc-admon-refer">
            <p><a href="../dev-java/the-space-configuration.html">The Space Configuration</a>
            </p>
        </div>
        <p>When a client connects to a space, a proxy is created that holds a connection which implements the space API. All client interaction is performed through this proxy.</p>
        <p>With XAP you can also create a Local Cache and a Local View.</p>
        <ul>
            <li>Local Cache : This client side cache maintains any object used by the application. The cache data is loaded on demand (lazily), based on the client application's read operations.</li>
            <li>Local View  : This client side cache maintains a specific subset of the data. The subset is predefined by the user. The cache is populated when the client application is started.
In both cases, updates are performed (objects are added/updated/removed) on the master space, the master space then propagates the changes to all relevant local views and caches.</li>
        </ul>
        <p>These two scenarios are only applicable for remote clients.</p>
        <div class="tc-admon-refer">
            <p><a href="../dev-java/client-side-caching.html">Client Side Caching</a>
            </p>
        </div>
        <h1><a name="the-space-object"></a>The Space Object</h1>
        <p>XAP supports two types of objects that can interact with the Space, POJOs and Documents.</p>
        <h2><a name="pojo"></a>POJO</h2>
        <p>Any POJO can be used to interact with the space as long it follows the Java Beans convention. The POJO needs to implement a default constructor, setters and getters for every property you want to store in the Space.</p><pre><code class="language-java">@SpaceClass
public class User {
  private Long id;
  private String name;
  private Double balance;
  private Double creditLimit;
  private EAccountStatus status;
  private Address address;
  private String[] comment;
  private Map&lt;String, String&gt; contacts;
  private List&lt;Group&gt; groups;
  private List&lt;Integer&gt; ratings;

  public User() {
  }

  @SpaceRouting
  @SpaceId(autoGenerate = false)
  public Long getId() {
    return id;
  }
}
</code></pre>
        <h2><a name="the-spaceid"></a>The SpaceId</h2>
        <p>The space generates a unique identifier (UID) for every object in one of the following ways:</p>
        <ul>
            <li>When a space object has no SpaceId attribute declared, the space auto-generates a UID for the object.</li>
            <li>When a space object has an attribute which is declared as SpaceId and marked as auto-generate=false, the UID is generated based on the value of the ID attribute the user is setting.</li>
            <li>When a space object has an attribute which is declared as SpaceId and marked as auto-generate=true, the UID is generated by the space and placed back into the attribute using the relevant setter method. In this case, the attribute must be of java.lang.String type.</li>
        </ul>
        <h2><a name="compound-spaceid"></a>Compound SpaceId</h2>
        <p>You might need to construct a space id that will be comprised from a user defined class rather than using a Numeric or String type field. In such a case your user defined class used as the SpaceId data type must implement the toString , hashCode and equals methods. The compound ID class must implement a toString method that return a unique String for each ID.</p>
        <div class="tc-admon-refer">
            <p><a href="../dev-java/space-object-id-operations.html">The Space Object Id</a>
            </p>
        </div>
        <h2><a name="defining-routing"></a>Defining Routing</h2>
        <p>Partitioning is used when the total number of objects is too big to be stored in a single space. In this case we will divide the data into several partitions. By designating an attribute on the space class as a partitioning key, the space proxy will then know to which partition a particular instance of the space class belongs to. The space proxy uses the entry's routing attribute hash code to determine the corresponding partition for it.</p>
        <div class="tc-admon-note">
            <p>The routing attribute can be explicitly set using the @SpaceRouting annotation for POJO entries or via the SpaceTypeDescriptorBuilder for document entries. If the routing attribute is not explicitly set, the space id attribute is used for routing. If the space id attribute is not defined, the first indexed attribute (alphabetically) is used for routing, otherwise the first attribute (alphabetically) is used for routing.</p>
        </div>
        <div class="tc-admon-refer">
            <p><a href="../dev-java/routing-in-partitioned-spaces.html">Routing in partitioned Space</a>
            </p>
        </div>
        <h1><a name="space-document"></a>Space Document</h1>
        <p>The GigaSpaces document API exposes the space as Document Store. A document, which is represented by the class SpaceDocument, is essentially a collection of key-value pairs, where the keys are strings and the values are primitives, String, Date, other documents, or collections thereof. Unlike POJOs, which force users to design a fixed data schema (in the form of a class definition) and adhere to it, a document is much more dynamic, users can add and remove properties at runtime as necessary. A Document always belongs to a certain type, represented by the class SpaceTypeDescriptor.</p>
        <p>To create a document we use a Map&lt;String,Object&gt; for its properties. The SpaceDocument object is instantiated by using the type name and properties. XAP provides a special implementation of a Hash Map called  DocumentProperties that provides a fluent API.</p>
        <p>Here is an example how you can create a SpaceDocument:</p><pre><code class="language-java">public SpaceDocument createDocumemt() {
     DocumentProperties properties = new DocumentProperties()
       .setProperty("CatalogNumber", "av-9876")
       .setProperty("Category", "Aviation")
       .setProperty("Name", "Jet Propelled Pogo Stick")
       .setProperty("Price", 19.99f)
       .setProperty("Tags",
            new String[] { "New", "Cool", "Pogo", "Jet" })
       .setProperty("Features",
            new DocumentProperties()
              .setProperty("Manufacturer", "Acme")
              .setProperty("RequiresAssembly", true)
              .setProperty("NumberOfParts", 42));

       return new SpaceDocument("Product", properties);
}
</code></pre>
        <p>In order to use the SpaceDocument, we need to register its schema first with the space:</p><pre><code class="language-java">public void registerProductType(GigaSpace space) {
     // Create type descriptor:
     SpaceTypeDescriptor typeDescriptor = new SpaceTypeDescriptorBuilder(
        "Product").idProperty("CatalogNumber")
        .routingProperty("Category")
        .addPropertyIndex("Name", SpaceIndexType.EQUAL)
        .addPropertyIndex("Price", SpaceIndexType.ORDERED).create();
     // Register type:
     space.getTypeManager().registerTypeDescriptor(typeDescriptor);
}
</code></pre>
        <p>Only properties with special roles like ID and Routing are part of the schema definition. These meta model settings cannot be changed without restarting the space or dropping the type, clearing all its instances and reintroducing it again.</p>
        <div class="tc-admon-note">
            <p>It is possible to write a POJO to the space and read it back as a document, and vice versa. This scenario is useful when you want to read or modify POJO objects without loading the concrete java classes.</p>
        </div>
        <div class="tc-admon-refer">
            <p><a href="../dev-java/document-pojo-interoperability.html">Document POJO Interoperability</a>
            </p>
        </div>
        <h1><a name="interacting-with-the-space"></a>Interacting with the Space</h1>
        <p>All space operations are relevant to both the POJO and Document.</p>
        <h2><a name="writing-an-object-to-space"></a>Writing an object to space:</h2>
        <p>When writing an object to the space, the object is created in space if it does not exist. If it already exists in space it will be updated. This is the default behavior of the write operation.</p><pre><code class="language-java">public void writeUser() {
     User user = new User();
     user.setId(new Long(1));
     user.setName("John Smith");
     user.setStatus(EAccountStatus.ACTIVE);

     // Write the user to the space
     space.write(user);
}
</code></pre>
        <p>It is also possible to write multiple objects in one operation to the space (batch mode). This can vastly improve the performance if you need to load many objects at once into the space.</p>
        <p>Here is an example on how you write multiple objects to the space:</p><pre><code class="language-java">public void writeUsers() {
     User[] users = new User[2];
     users[0] = new User();
     users[0].setId(new Long(1));
     users[0].setName("John Doe");
     users[0].setStatus(EAccountStatus.ACTIVE);

     users[1] = new User();
     users[1].setId(new Long(2));
     users[1].setName("John Doe");
     users[1].setStatus(EAccountStatus.ACTIVE);

     space.writeMultiple(users);
}
</code></pre>
        <p>There are several options to override the default behavior of the write operation. You can change the lifetime of an object by supplying a LEASE to the operation. You can also change the modifier on the operation to change the behavior.</p>
        <p>Here is an example:</p><pre><code class="language-java">public void writeOnlyWithLease() {
     User user = new User();
     user.setId(new Long(1));
     user.setName("John Smith");
     user.setStatus(EAccountStatus.ACTIVE);
     space.write(user, 0, 10000, WriteModifiers.WRITE_ONLY);
}
</code></pre>
        <p>In this example, we are writing an object to the space with zero delay, 10 seconds to live and write only if the object does not already exist in the space. If the object already exists, an exception will be thrown.</p>
        <div class="tc-admon-refer">
            <p><a href="../dev-java/the-space-operations.html">The Space Operations</a>
            </p>
        </div>
        <h2><a name="updating-an-object-in-space"></a>Updating an object in space</h2>
        <p>When you want to update only a couple of attributes on an object in space, you can use the change operation and update specific fields or even nested fields or modify collections and maps without having to supply the entire collection or map for the operation. With the following change operation example it is not necessary to read the object first from the space to update it. The Change API reduces a normal two step operation to a one step operation. This operation can vastly improve performance when you have an object with many attributes and you only need to update one or a couple of attributes.</p><pre><code class="language-java">public void ChangeSet() {
      User user = new User();
      user.setId(new Long(1));
      user.setName("John Doe");
      user.setStatus(EAccountStatus.ACTIVE);
      space.write(user);

      IdQuery&lt;User&gt; idQuery = new IdQuery&lt;User&gt;(User.class, new Long(1));
      ChangeResult&lt;User&gt; changeResult = space.change(idQuery,
        new ChangeSet().set("status", EAccountStatus.BLOCKED));

     if (changeResult.getNumberOfChangedEntries() == 0) {
        System.out.println("Entry does not exist");
     }
}
</code></pre>
        <p>There are several other change operations available; "increment', "decrement', "addToCollection', "removeFromCollection' etc.</p>
        <div class="tc-admon-refer">
            <p><a href="../dev-java/change-api-overview.html">The Change API</a>
            </p>
        </div>
        <h1><a name="querying-the-space"></a>Querying the Space</h1>
        <p>Now we are ready to query the space. XAP provides several ways to perform queries against the space:</p>
        <ul>
            <li>Query by ID</li>
            <li>Query by Template</li>
            <li>Query by SQL</li>
        </ul>
        <h2><a name="query-by-id"></a>Query by ID</h2>
        <p>This is the simplest and fasted way to retrieve objects from the space.</p>
        <p>Here is an example of a query by id:</p><pre><code class="language-java">public User findUserById() {
     return space.readById(User.class, new Long(1));
}
</code></pre>
        <p>You can also perform a bulk read for multiple Id's</p><pre><code class="language-java">public User[] findUsersByIds() {
     ReadByIdsResult&lt;User&gt; result = space.readByIds(User.class, new Long[] {1l, 2l, 3l });
     return result.getResultsArray();
}
</code></pre>
        <h2><a name="query-by-template"></a>Query by Template</h2>
        <p>Template matching (match by example) is a simple way to query the space. The template is a POJO of the desired entry type, and the attributes which are set on the template (i.e. not null) are matched against the respective attributes of entries of the same type in the space. Attributes with null values are ignored (not matched).</p>
        <p>The following examples assume the default constructor of the User class initializes all its attributes to null.</p>
        <p>Read an entry of type User where the name is "John Doe':</p><pre><code class="language-java">public User findUserByTemplate() {
     User user = new User();
     user.setName("John Doe");
     return space.read(user);
}
</code></pre>
        <p>You can also perform a bulk read with templates. In the example below will read all users that have a status of ACTIVE:</p><pre><code class="language-java">public User[] findUsersByTemplate() {
     User user = new User();
     user.setStatus(EAccountStatus.ACTIVE);
     return space.readMultiple(user);
}
</code></pre>
        <div class="tc-admon-note">
            <p>Template Matching support inheritance relationships, so that entries of a sub-class are visible in the context of the super class, but not the other way around.</p>
        </div>
        <h2><a name="sql-query"></a>SQL Query</h2>
        <p>The SQLQuery class is used to query the space with an SQL-like syntax. The query statement includes only the WHERE statement part. An SQLQuery is composed from the class of entry to query and an expression in SQL syntax.</p><pre><code class="language-java">public User[] sqlFindUsersByName() {
     SQLQuery&lt;User&gt; query = new SQLQuery&lt;User&gt;(User.class,"name = 'John Doe'");
     return space.readMultiple(query);
}

public User[] sqlFindUsersByNameAndCreditLimit() {
     SQLQuery&lt;User&gt; query = new SQLQuery&lt;User&gt;(User.class,"name = 'John Doe' AND creditLimit &gt; 1000");
     return space.readMultiple(query);
}

public User[] sqlFindUsersByNameAndIds() {
     SQLQuery&lt;User&gt; query = new SQLQuery&lt;User&gt;(User.class,"name = 'John Doe' AND id IN(1L,3L,5L)");
     return space.readMultiple(query);
}
</code></pre>
        <div class="tc-admon-refer">
            <p><a href="../dev-java/query-sql.html">SQL Query</a>
            </p>
        </div>
        <h2><a name="parameterized-queries"></a>Parameterized Queries</h2>
        <p>You can separate the values for the SQL criteria expression by placing a "?' symbol instead of the actual value in the expression. When executing the query, the conditions that includes "?' are replaced with the corresponding parameter values supplied via the setParameter  method.</p>
        <p>For example:</p><pre><code class="language-java">public User[] sqlParameterFindUsersByName() {
     SQLQuery&lt;User&gt; query = new SQLQuery&lt;User&gt;(User.class, "name = ?").setParameter(1, "John Doe");
     return space.readMultiple(query);
}

public User[] sqlParameterFindUsersByNameAndCreditLimit() {
     SQLQuery&lt;User&gt; query = new SQLQuery&lt;User&gt;(User.class,"name = ? AND creditLimit &gt; ?");
     query.setParameter(1, "John Doe");
     query.setParameter(2, new Double(1000));
     return space.readMultiple(query);
}
</code></pre>
        <h2><a name="nested-property-queries"></a>Nested property queries</h2>
        <p>Many times a class has embedded classes as attributes. You can query for attributes within the embedded classes. Matching a nested attribute is done by specifying a Path which describes how to obtain its value. For example, our user class has an embedded attribute of an Address that has a zipCode attribute.</p>
        <p>Here is an example how you can query the space for all users that have a zip code of "12345'.</p><pre><code class="language-java">public User[] sqlFindUsersByZipCode() {
     SQLQuery&lt;User&gt; query = new SQLQuery&lt;User&gt;(User.class,"address.zipCode = 12345");
     return space.readMultiple(query);
}
</code></pre>
        <h2><a name="nested-collections"></a>Nested Collections</h2>
        <p>It is possible to query embedded collections. Our user class has a collection groups that he belongs to. We can query the space for all users that belong to a certain group:</p><pre><code class="language-java">public User[] findUsersByGroup() {
   SQLQuery&lt;User&gt; sqlQuery = new SQLQuery&lt;User&gt;(User.class,"groups[*].id = 1L");
   return space.readMultiple(sqlQuery);
}
</code></pre>
        <p>There are several additional query options available. For example you can query Nested Maps by key,query with Regular Expression, Enum attributes and others.</p>
        <div class="tc-admon-refer">
            <p><a href="../dev-java/query-nested-properties.html">Query Netsed Properties</a>
            </p>
        </div>
        <h2><a name="query-returning-partial-results"></a>Query returning partial results</h2>
        <p>In some cases when querying the space for objects only specific attributes of an objects are required and not the entire object (delta read). For that purpose the Projection API can be used where you can specify which attributes are of interest and the space will only populate these attributes with the actual data when the result is returned back to the user. This approach reduces network overhead and can vastly improve performance.</p>
        <p>In this example below we are just interested in the name attribute of the user object:</p><pre><code class="language-java">public User[] findUsersByNameAndProjection() {
     SQLQuery&lt;User&gt; query = new SQLQuery&lt;User&gt;(User.class,"name = ?");
     query.setParameter(1, "John Doe");
     query.setProjections("name");

     return space.readMultiple(query);
}
</code></pre>
        <div class="tc-admon-refer">
            <p><a href="../dev-java/query-partial-results.html">Query Partial results</a>
            </p>
        </div>
        <h2><a name="document-queries"></a>Document Queries</h2>
        <p>You can also query the space for documents. Just like the POJO queries, you can use query by ID, template and SQLQuery.</p>
        <p>Here are some examples how you can query the space for documents:</p><pre><code class="language-java">public SpaceDocument readProductById(GigaSpace gigaSpace) {
    return gigaSpace.readById(new IdQuery&lt;SpaceDocument&gt;("Product", "hw-1234"));
}

public SpaceDocument readProductByTemplate() {
     SpaceDocument template = new SpaceDocument("Product");
     template.setProperty("Name", "Jet Propelled Pogo Stick");
     return space.read(template);
}

public SpaceDocument[] readProductsBySQL() {
      SQLQuery&lt;SpaceDocument&gt; query = new SQLQuery&lt;SpaceDocument&gt;("Product","Price &gt; ?");
      query.setParameter(1, 19.99f);
      return space.readMultiple(query);
}
</code></pre>
        <div class="tc-admon-refer">
            <p><a href="../dev-java/document-api.html">The Document API</a>
            </p>
        </div>
        <h2><a name="geospatial-query"></a>Geospatial Query</h2>
        <p>Spatial queries make use of geometry data types such as points, circles and polygons and these queries consider the spatial relationship between these geometries.</p>
        <p>Suppose we want to write an application to locate nearby gas stations.  First, we create a <code>GasStation</code> class which includes the location and address of the gas station:</p>
        <p>And here is the corresponding java class:</p><pre><code class="language-java">import org.openspaces.spatial.shapes.Point;

import com.gigaspaces.annotation.pojo.SpaceClass;
import com.gigaspaces.annotation.pojo.SpaceId;

@SpaceClass
public class GasStation {

    private Long id;

    private Point location;

    public Point getLocation() {
        return location;
    }

    public void setLocation(Point location) {
        this.location = location;
    }
    
    @SpaceId
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }
}

</code></pre>
        <p>Let's write some gas stations into the Space:</p><pre><code class="language-java">    GigaSpace gigaSpace = new GigaSpaceConfigurer(new EmbeddedSpaceConfigurer("geoSpace")).gigaSpace();

    GasStation gs = new GasStation();
    gs.setId(new Long(1));
    gs.setLocation(ShapeFactory.point(10.0d, 10.0d));

    gigaSpace.write(gs);        
</code></pre>
        <p>Next, we can query for a gas station within a certain radius of our location:</p><pre><code class="language-java">    Point p = ShapeFactory.point(7.5d, 7.5d);

    SQLQuery&lt;GasStation&gt; query = new SQLQuery&lt;GasStation&gt;(GasStation.class, "location spatial:within ?")
                .setParameter(1, ShapeFactory.circle(p, 4.5d));
    GasStation station = gigaSpace.read(query);

    if (station != null) {
        System.out.println("Found a GasStation :" + station);
    }
}
</code></pre>
        <h3><a name="shapes"></a>Shapes</h3>
        <p>XAP supports the following shapes:</p>
        <table>
            <thead>
                <tr>
                    <th align="left">Shape</th>
                    <th align="left">Description</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td align="left">Point</td>
                    <td align="left">A point, denoted by <code>X</code> and <code>Y</code> coordinates.</td>
                </tr>
                <tr>
                    <td align="left">LineString</td>
                    <td align="left">A finite sequence of one or more consecutive line segments.</td>
                </tr>
                <tr>
                    <td align="left">Circle</td>
                    <td align="left">A circle, denoted by a point and a radius.</td>
                </tr>
                <tr>
                    <td align="left">Rectangle</td>
                    <td align="left">A rectangle aligned with the axis (for non-aligned rectangles use Polygon).</td>
                </tr>
                <tr>
                    <td align="left">Polygon</td>
                    <td align="left">A finite sequence of consecutive line segments which denotes a bounded area.</td>
                </tr>
            </tbody>
        </table>
        <h3><a name="queries"></a>Queries</h3>
        <p>Spatial queries are available through the <code>spatial:</code> extension to the <a href="../dev-java/query-sql.html">SQL query syntax</a>. The following operations are supported:</p>
        <table>
            <thead>
                <tr>
                    <th align="left">Query</th>
                    <th align="left">Description</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td align="left">shape1 spatial:intersects shape2 </td>
                    <td align="left">The intersection between shape1 and shape 2 is not empty (i.e. some or all of shape1 overlaps some or all of shape2).</td>
                </tr>
                <tr>
                    <td align="left">shape1 spatial:within shape2</td>
                    <td align="left">shape1 is within (contained in) shape2, boundaries inclusive.</td>
                </tr>
                <tr>
                    <td align="left">shape1 spatial:contains shape2</td>
                    <td align="left">shape1 contains shape2, boundaries inclusive.</td>
                </tr>
            </tbody>
        </table>
        <div class="tc-admon-refer">
            <p><a href="../dev-java/query-geospatial.html">Geospatial Queries</a>
            </p>
        </div>
        <h2><a name="removing-objects-from-space"></a>Removing Objects from Space</h2>
        <p>To remove objects from a space you can use the take or the clear operation.</p>
        <h3><a name="take-operation"></a>Take operation</h3>
        <p>The take operation returns an object and removes it from the space. XAP provides several options for the take operation:</p>
        <ul>
            <li>Take by ID</li>
            <li>Take by template</li>
            <li>Take by SQLQuery</li>
            <li>Take multiple</li>
        </ul>
        <p>Here are some examples:</p><pre><code class="language-java">public User takeUserById() {
   return space.takeById(User.class, 1L);
}

public User takeUserByTemplate() {
   User template = new User();
   template.setName("John Doe");
   return space.take(template);
}

public User[] takeUsersBySQL() {
     SQLQuery&lt;User&gt; query = new SQLQuery&lt;User&gt;(User.class,"status = ?");
     query.setParameter(1, EAccountStatus.BLOCKED);
   return space.takeMultiple(query);
}
</code></pre>
        <h2><a name="clear-operation"></a>Clear operation</h2>
        <p>The clear operation removes objects from a space without returning them.
Here are some examples:</p><pre><code class="language-java">public void clearUserByTemplate() {
     User template = new User();
     space.clear(template);
}

public void clearUserBySQL() {
     SQLQuery&lt;User&gt; query = new SQLQuery&lt;User&gt;(User.class, "name = ?");
     query.setParameter(1, "John Doe");
     space.clear(query);
}

// clear all objects in space
public void clearAllObjectInSpace() {
     space.clear(null);
}
</code></pre>
        <div class="tc-admon-refer">
            <p><a href="../dev-java/the-space-operations.html">The Space Operations</a>
            </p>
        </div>
        <h2><a name="aggregation"></a>Aggregation</h2>
        <p>The Aggregators allow you to perform the entire aggregation activity at the space side avoiding any data retrieval back to the client side. Only the result of each aggregation activity performed with each partition is returned back to the client side where all the results are reduced and returned to the client application.</p><pre><code class="language-java">import static org.openspaces.extensions.QueryExtension.*;
...
SQLQuery&lt;Employee&gt; query = new SQLQuery&lt;Employee&gt;(Employee.class,"country=? OR country=? ");
query.setParameter(1, "UK");
query.setParameter(2, "U.S.A");

// retrieve the maximum value stored in the field "age"
Number maxAgeInSpace = max(space, query, "age");
/// retrieve the minimum value stored in the field "age"
Number minAgeInSpace = min(space, query, "age");
// Sum the "age" field on all space objects.
Number combinedAgeInSpace = sum(space, query, "age");
// Sum's the "age" field on all space objects then divides by the number of space objects.
Double averageAge = average(space, query, "age");
// Retrieve the space object with the highest value for the field "age".
Person oldestPersonInSpace = maxEntry(space, query, "age");
/// Retrieve the space object with the lowest value for the field "age".
Person youngestPersonInSpace = minEntry(space, query, "age");
</code></pre>
        <p>XAP also supports, <code>Compound</code>, <code>Embedded Fields</code> and <code>Group</code> Aggregation.</p>
        <div class="tc-admon-refer">
            <p><a href="../dev-java/aggregators.html">Aggregators</a>
            </p>
        </div>
        <h1><a name="indexing"></a>Indexing</h1>
        <p>To improve performance, it is possible to index one or more attributes for an object. The space maintains additional data for indexed attributes, which shortens the time required to determine a match resulting in improved performance. However, indexes consume more resources and impacts the write operations performance.</p>
        <h2><a name="inheritance"></a>Inheritance</h2>
        <p>By default, an attribute's index is inherited in sub classes (i.e. if an attribute is indexed in a super class, it is also indexed in a sub class). If you need to change the index type of an attribute in a subclass you can override the attribute and annotate it with @SpaceIndex using the requested index type (to disable indexing use NONE).</p>
        <h2><a name="space-index"></a>Space Index</h2>
        <p>There are three Space index types provided:</p>
        <ul>
            <li><span class="tc-bold">EQUAL</span> - performs equality matching (equal to/not equal to).</li>
            <li><span class="tc-bold">ORDERED</span> - performs ordered matching (bigger than/less than).</li>
            <li><span class="tc-bold">EQUAL_AND_ORDERED</span> - performs both equality and ordered matching, and uses a larger memory footprint than the other indexing types.</li>
        </ul>
        <p>Here is an example how you can define indexes:</p><pre><code class="language-java">@SpaceClass
public class User {

    private Long id;
    private String name;
    private Double balance;
    private Double creditLimit;
    private EAccountStatus status;
    private Address address;
    private Map&lt;String, String&gt; contacts;

    public User() {
    }

    @SpaceId(autoGenerate = false)
    @SpaceRouting
    public Long getId() {
        return id;
    }

    @SpaceIndex(type = SpaceIndexType.EQUAL)
    public String getName() {
        return name;
    }

    @SpaceIndex(type = SpaceIndexType.ORDERED)
    public Double getCreditLimit() {
        return creditLimit;
    }
}
</code></pre>
        <h2><a name="compound-indexing"></a>Compound Indexing</h2>
        <p>A Compound Index is a space index composed from several attributes or nested attributes. Each attribute of a compound index is called a segment and each segment is described by its path.</p>
        <p>Here is an example of a compound index:</p><pre><code class="language-java">@CompoundSpaceIndexes({ @CompoundSpaceIndex(paths = { "name", "creditLimit" }) })
@SpaceClass
public class User {
     private Long id;
     private String name;
     private Double balance;
     private Double creditLimit;
     private EAccountStatus status;
     private Address address;
     private String[] comment;
}

// Here is a query that will use this index
SQLQuery&lt;User&gt; query = new SQLQuery&lt;User&gt;(User.class,"name = 'John Doe' AND creditLimit &gt; 1000");
</code></pre>
        <p>There are several additional indexing options available. For example you can index nested attributes, Nested Maps, Collections, nested attributes within a Collection, free text search and others.</p>
        <div class="tc-admon-refer">
            <p><a href="../dev-java/indexing-overview.html">Indexing</a>
            </p>
        </div>
        <h1><a name="best-practice"></a>Best Practice</h1>
        <p><span class="tc-bold">When you code your space classes make sure:</span>
        </p>
        <ul>
            <li>there are indexes for all relevant attributes including nested attributes you use for queries</li>
            <li>numeric attribute queried with between / greater / less than should have an ordered index.</li>
            <li>compound indexes should be used for attributes queried using AND query</li>
            <li>space classes have empty no arg constructor</li>
            <li>all nested classes are serializable</li>
            <li>do not use  int, long, etc. integer attributes, instead use Long.</li>
            <li>when possible use writeMultiple.</li>
            <li>use projection for read/readMultiple</li>
            <li>use clear for data removal and not take or takeMultiple</li>
            <li>no huge collections with many items</li>
            <li>use change api instead of update, especially if collections are used.</li>
        </ul>
        <h1><a name="other-data-access-apis"></a>Other Data Access APIs</h1>
        <p>XAP provides a JDBC Driver, JPA API, MAP and Memcached APIs.</p>
        <div class="tc-admon-refer">
            <p><a href="../dev-java/other-data-access-apis.html">Other Data Access API's</a>
            </p>
        </div>
        <h1><a name="spring-integration"></a>Spring Integration</h1>
        <p>All XAP components can be wired and configured with the application using corresponding Spring Beans.</p>
        <p><span class="tc-bold">The GigaSpaces Spring Integration supports:</span>
        </p>
        <ul>
            <li>Spring Automatic Transaction Demarcation<br /></li>
            <li>Spring Data<br /></li>
            <li>Spring JMS<br /></li>
            <li>Spring JPA<br /></li>
            <li>Spring Hibernate<br /></li>
            <li>Spring Remoting<br /></li>
            <li>String Batch<br /></li>
            <li>Spring Security<br /></li>
            <li>Mule</li>
        </ul>
        <p>Lets look at a Spring configuration file that represents the creation of an embedded space:</p><pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
    xmlns:os-core="http://www.openspaces.org/schema/core" xmlns:os-events="http://www.openspaces.org/schema/events"
    xmlns:os-remoting="http://www.openspaces.org/schema/remoting"
    xmlns:os-sla="http://www.openspaces.org/schema/sla"
    xsi:schemaLocation="
   http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-[%=Versions.spring-short%].xsd
   http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-[%=Versions.spring-short%].xsd
   http://www.openspaces.org/schema/core http://www.openspaces.org/schema/[%=Versions.product-version-short%]/core/openspaces-core.xsd"&gt;

    &lt;!-- Scan the packages for annotations / --&gt;
    &lt;context:component-scan base-package="xap" /&gt;

    &lt;!-- Enables to configure Spring beans through annotations --&gt;
    &lt;context:annotation-config /&gt;

    &lt;!-- A bean representing a space (an IJSpace implementation) --&gt;
    &lt;os-core:embedded-space id="space" space-name="tutorialSpace" /&gt;

    &lt;!-- Define the GigaSpace instance that the application will use to access the space --&gt;
    &lt;os-core:giga-space id="xapTutorialSpace" space="space"/&gt;
&lt;/beans&gt;
</code></pre>
        <p>And here is the code to access the Spring bean within your application:</p><pre><code class="language-java">public void findSpace()  {
    FileSystemXmlApplicationContext context = new FileSystemXmlApplicationContext(
    "classpath:/spring/application-context.xml");

    GigaSpace space = (GigaSpace) context.getBean("xapTutorialSpace");
}
</code></pre>
        <div class="tc-admon-note">
            <p>In the following parts of this tutorial we will introduce you the different schemas that support the XAP Spring integration. We will also use the Annotations to configure and inject components.</p>
        </div>
    </body>
</html>