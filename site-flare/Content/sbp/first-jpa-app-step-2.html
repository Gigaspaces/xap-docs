<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
<head></head>
<body>
<h1>Scaling the Data Access Layer</h1>
  

<p>This step explains how to utilize the power of the grid when implementing the data access layer of the PetClinic application (namely the <code>Clinic</code> interface), and seamlessly use distributed computing paradigms such as Map/Reduce and data and processing colocation.</p>

<h1><a name="preparing-the-petclinicservice">&#160;</a>Preparing the PetClinicService</h1>

<p>The <code>PetClinicService</code> is an implementation of the <code>Clinic</code> interface that the Spring MVC layer of the application is using. The easiest way to implement this service is simply define an <code>EntityManagerFactory</code> that accesses the remote space from within the web application (similar the traditional database backed implementation). But in our case we want to be able to take advantage of the built in capabilities  that GigaSpaces XAP provides for scaling your business logic:</p>

<ul>
<li>Data and processing colocation: instead of running your JPA access code away from the data (namely in the web application), you can actually run it with the data, such that all JPA operations are done in memory</li>
<li>Map/Reduce: this means that you're able to run your business logic on multiple nodes on the space cluster, and reduce the results back at the client side to provide the same experience as invoking the business logic on the client side.</li>
<li>Smart content based routing: In a distributed data store, it's very important in terms of performance and scalability to be able to route each data accessing operation to the right node, i.e. the node on which the data your operate on actually resides instead of sending the operation to all of the cluster nodes.</li>
</ul>

<p>We can easily achieve all of the above by using the GigaSpaces XAP <a href="/xap/14.0/dev-java/space-based-remoting.html">Space Based Remoting</a> support, and making a few small adaptations to the clinic interface (adding a few annotations to it).</p>

<h1><a name="adjusting-the-clinic-interface">&#160;</a>Adjusting the Clinic Interface</h1>

<p>As mentioned above, we will use <a href="/xap/14.0/dev-java/space-based-remoting.html">Space Based Remoting</a> to back the <code>Clinic</code> interface. The actual implementation will run on each of the Space nodes we will deploy. The first thing we need to do is declare for each operation (method) whether it will be sent to the entire cluster or to a specific Space partition. In case an operation is sent to the entire cluster, we also need to tell the client how to aggregate (or <span class="tc-italic">reduce</span>) the results on from all cluster members. This is done using a reducer class which implements the <a href="[%=Links.ApiJavaDoc%]/index.html?org/openspaces/remoting/RemoteResultReducer.html">RemoteResultReducer</a> interface.</p>

<p>All of the above is done by applying the <code>@ExecutorRemotingMethod</code> annotation (new in 8.0.1) to each of the methods. This annotation has several attributes:</p>

<ul>
<li><code>broadcast</code> - should be set to <code>true</code> in case the entire cluster must be touched or false, in case the method only touches specific partition. In case of a cluster wide task the reducer attribute must be applied. In case of the <code>Clinic</code> interface, methods that need to scan the entire data set such as <code>getVets()</code>, <code>findOwners()</code> or <code>loadPet()</code> must be invoked against all nodes and therefore will be marked as <code>broadcast = true</code>.</li>
<li><code>reducer</code> - specifies the name of the Spring bean to use for results aggregation.</li>
</ul>

<p>The <code>Clinic</code> service has 3 reducers: the <code>getVets()</code> method uses the <code>GetVetsReducer</code> class. The <code>findOwners()</code> method uses the <code>FindOwnersReducer</code> class, and the <code>loadPet()</code> method uses the <code>LoadPetResultReducer</code> class.
In case the invoked method needs to query a specific partition, we should specify to which partition the call will be routed. We can do this using the <a href="[%=Links.ApiJavaDoc%]/index.html?org/openspaces/remoting/Routing.html">@Routing</a> annotation on a specific method parameters, or the a use an implementation of the <a href="[%=Links.ApiJavaDoc%]/index.html?org/openspaces/remoting/RemoteRoutingHandler.html">RemoteRoutingHandler</a> interface and assign it to the <code>remoteRoutingHandler</code> attribute. This gives you the required flexibility and keeps the implementation cleaner.
The <code>Clinic</code> service is using 2 handlers: the <code>storePet()</code> and the <code>deletePet()</code> methods use the <code>PetRoutingHandler</code> class. The <code>storeVisit()</code> method uses the <code>VisitRoutingHandler</code>.</p>

<p>Finally, we specify a <a href="[%=Links.ApiJavaDoc%]/index.html?org/openspaces/remoting/RemoteInvocationAspect.html">RemoteInvocationAspect</a> implementation which intercepts the <code>Clinic</code> methods before they are actually sent to the space for execution. In our case there are two aspects:</p>

<ul>
<li>The <code>PetTypesAspect</code>, which is a simple aspect that returns the <code>PetType</code> enum values so that the client call will never be sent to the space (since it's not needed).</li>
<li>The <code>IdGeneratingInvocationAspect</code>, which generates unique entity IDs when needed (currently XAP JPA does not support auto-generation of non-String IDs). This is essential when writing new objects to the space using JPA. The aspect simply invokes an ID generation service for generating new cluster wide unique IDs before actually sending the call to the space.
Here's a snippet of the <code>Clinic</code> interface after adding all the XAP related annotations:</li>
</ul>

<pre><code class="language-java">...
public interface Clinic {
   /**
    - Retrieve all &lt;code&gt;Vet&lt;/code&gt;s from the data store.
    - @return a &lt;code&gt;Collection&lt;/code&gt; of &lt;code&gt;Vet&lt;/code&gt;s
    */
    @ExecutorRemotingMethod(broadcast=true, remoteResultReducer = "getVetsReducer")
    Collection&lt;Vet&gt; getVets() throws DataAccessException;

   /**
    - Retrieve all &lt;code&gt;PetType&lt;/code&gt;s from the data store.
    - @return a &lt;code&gt;Collection&lt;/code&gt; of &lt;code&gt;PetType&lt;/code&gt;s
    */
    @ExecutorRemotingMethod(broadcast=false, remoteInvocationAspect="petTypesAspect")
    Collection&lt;PetType&gt; getPetTypes() throws DataAccessException;

   /**
    - Retrieve &lt;code&gt;Owner&lt;/code&gt;s from the data store by last name,
    - returning all owners whose last name &lt;i&gt;starts&lt;/i&gt; with the given name.
    - @param lastName Value to search for
    - @return a &lt;code&gt;Collection&lt;/code&gt; of matching &lt;code&gt;Owner&lt;/code&gt;s
    - (or an empty &lt;code&gt;Collection&lt;/code&gt; if none found)
    */
    @ExecutorRemotingMethod(broadcast=true, remoteResultReducer="findOwnersReducer")
    Collection&lt;Owner&gt; findOwners(String lastName) throws DataAccessException;

...
</code></pre>

<p>The clinic service relies on a connection to the remote space. This connection is initialized in a Spring configuration file (or alternatively can be done within the application's code). The web application's Spring configuration file is located at <code>WEB-INF/spring/applicationContext-gs.xml</code> within the web application. See below the Spring configuration snippet.</p>

<pre><code class="language-xml">...
 &lt;os-core:space-proxy  id="space" name="petclinic"   lookup-timeout="20000" lookup-groups="${user.name}"/&gt;

    &lt;os-core:distributed-tx-manager id="jiniTransactionManager" /&gt;

    &lt;os-core:giga-space id="petclinic" space="space" tx-manager="jiniTransactionManager"/&gt;

    &lt;bean id="dummyDataCreator" class="org.springframework.samples.petclinic.util.DummyDataCreator"&gt;
        &lt;property name="dataFileResource" value="classpath:META-INF/dummyData.json"/&gt;
    &lt;/bean&gt;

    &lt;bean id="idGenerator" class="org.springframework.samples.petclinic.gigaspaces.idgen.IdGeneratorImpl"/&gt;
    &lt;bean id="idGeneratingInvocationAspect" class="org.springframework.samples.petclinic.gigaspaces.IdGeneratingInvocationAspect"/&gt;

    &lt;bean id="findOwnersReducer" class="org.springframework.samples.petclinic.gigaspaces.FindOwnersReducer"/&gt;
    &lt;bean id="getVetsReducer" class="org.springframework.samples.petclinic.gigaspaces.GetVetsReducer"/&gt;
    &lt;bean id="petTypesAspect" class="org.springframework.samples.petclinic.gigaspaces.PetTypesAspect"/&gt;
    &lt;bean id="loadPetResultReducer" class="org.springframework.samples.petclinic.gigaspaces.LoadPetResultReducer"/&gt;
    &lt;bean id="petRoutingHandler" class="org.springframework.samples.petclinic.gigaspaces.PetRoutingHandler"/&gt;
    &lt;bean id="visitRoutingHandler" class="org.springframework.samples.petclinic.gigaspaces.VisitRoutingHandler"/&gt;

    &lt;os-remoting:executor-proxy id="clinicProxy" giga-space="petclinic" interface="org.springframework.samples.petclinic.Clinic"/&gt;

    &lt;context:annotation-config/&gt;

    &lt;tx:annotation-driven transaction-manager="jiniTransactionManager"/&gt;

&lt;/beans&gt;
</code></pre>

<h1><a name="changes-to-the-service-implementation">&#160;</a>Changes to the Service Implementation:</h1>

<p>The following changes had been made to the service implementation:
The <code>PetClinicService.loadPet(int id)</code> method can't use the JPA <code>EntityManager.find()</code> method since <code>Pet</code> is not a root entity in the space but rather an embedded object within the <code>Owner</code> entity. Therefore, this method must fetch the Owner using a query with the JPQL <code>JOIN</code> syntax and then iterate through the <code>Owner</code>'s <code>Pet</code>s to return the right <code>Pet</code> instance.
The same method of implementation is also applied in the <code>deletePet()</code> and <code>storeVisit()</code> methods.</p>

<pre><code class="language-java">...
@Transactional(readOnly = true)
public Pet loadPet(int id) {
    Query query = em.createQuery("SELECT o FROM org.springframework.samples.petclinic.Owner o JOIN o.petsInternal p WHERE p.id = :id");
    query.setParameter("id", id);
    List&lt;Owner&gt; owners = query.getResultList();
    if (!owners.isEmpty()) {
        Owner owner = owners.get(0);
        for (Pet pet : owner.getPets()) {
           if (pet.getId() == id) {
               return pet;
           }
        }
    }
    return null;
}
...
</code></pre>

<h1><a name="the-id-generator">&#160;</a>The Id Generator</h1>

<p>The Id Generator functionality is part of the processor module. It consists of the following classes:</p>

<ul>
<li>The <code>IdGenerator</code> interface that exposes the <code>generateId()</code> method.</li>
<li>The <code>IdGeneratorImpl</code> class that implements <code>IdGenerator</code> interface.</li>
<li>The <code>IdCounterEntry</code> which is the Id counter stored in the space.</li>
<li>The <code>IdObjectInitializer</code> which is the Spring initializing bean that writes the Id counter entry to the space when the application is initialized.
The Id generator implementation is quite straight forward. Since all the partitions are part of the same space, it is the natural context for storing the Id counter.
The initializer (<code>IdObjectInitializer</code>) writes the counter only to the primary node of the first partition of the space when the application starts.
Whenever the Clinic service needs a new unique Id, it invokes the <code>IdGeneratorImpl.generateId()</code> that gets a range of IDs from the space whenever it is out of IDs and returns  the current Id from the range and increment the counter by one.
You can find more details on the cluster wide Id Generator pattern <a href="/sbp/global-id-generator.html">here</a>.</li>
</ul>

<pre><code class="language-java">...
public class IdGeneratorImpl implements IdGenerator {
    @Resource
    private GigaSpace gigaSpace;

    private int currentId = 0;
    private int idLimit = -1;

    public IdGeneratorImpl(){}

    @Transactional(propagation= Propagation.REQUIRES_NEW)
    public synchronized Integer generateId() {
        if (currentId &lt; 0 || currentId &gt; idLimit) {
            getNextIdBatchFromSpace();
        }
        return currentId++;
    }

    private void getNextIdBatchFromSpace() {
        IdCounterEntry idCounterEntry = gigaSpace.readById(IdCounterEntry.class,0,0, 5000, ReadModifiers.EXCLUSIVE_READ_LOCK);
        if (idCounterEntry == null) {
            throw new RuntimeException("Could not get ID object from Space");
        }
        int[] range = idCounterEntry.getIdRange();
        currentId = range[0];
        idLimit = range[1];
        gigaSpace.write(idCounterEntry, Lease.FOREVER, 5000, UpdateModifiers.UPDATE_ONLY);
    }
}
...
</code></pre>

</body>
</html>