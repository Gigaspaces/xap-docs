<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
    <head>
    </head>
    <body>
        <h1 class="tc-pagetitle">Data Types, Schema Types and Schema Evolution</h1>
        <div>
            <h1>What Kinds of Data Stores are Available in <MadCap:variable name="General.ProductNameXAP" />?</h1>
            <p>When a Data Store object is defined in <MadCap:variable name="General.ProductNameXAP" />, the object can be defined as a <a href="https://docs.gigaspaces.com/latest/dev-java/pojo-overview.html">Space Object</a> or a <a href="https://docs.gigaspaces.com/latest/dev-java/document-overview.html">Space Document</a>.</p>
            <p>Within each object type, the data schema can be defined with:</p>
            <ul>
                <li>Fixed or static properties (columns), sometimes referred to as  <i>schema on write</i>,</li>
                <li><a href="https://docs.gigaspaces.com/latest/dev-dotnet/poco-dynamic-properties.html?Highlight=dynamic">Dynamic properties</a>, sometimes referred to as <i>schema on read</i>, or</li>
                <li>Hybrid, a combination of both fixed and dynamic properties.</li>
            </ul>
            <p>The choice of object type and schema definition can have a profound impact on an application's memory footprint and processing speed. Fortunately, <MadCap:variable name="General.ProductNameXAP" /> provides a technique called<b> <MadCap:variable name="General.SchemaEvolutionWithoutDowntime" /></b> that allows an existing schema to be changed with minimal impact on the system.</p>
        </div>
        <h1>Schema Evolution - Changing a Schema</h1>
        <p>When a change is required to the underlying structure or schema of an object, this change process is referred to as <b>Schema Evolution</b>.</p>
        <h2>Methods for Schema Evolution</h2>
        <p>There are three general approaches for schema evolution:</p>
        <ul>
            <li>Use of dynamic properties</li>
            <li>In-place schema evolution with downtime</li>
            <li>Changing schema using static properties and redeploying the space - <b>Schema Evolution Without Downtime</b>.</li>
        </ul>
        <p>&#160;</p>
        <h3>Schema Evolution by Use of Dynamic Properties</h3>
        <p>The easiest way to achieve schema evolution is via dynamic properties - each entry can store a set of dynamic properties, which are not bound by the type schema. In this case schema evolution is automatic - your app simply starts writing entries with additional properties. No change is required in the space.</p>
        <p>The downside is that the memory requirement increases - because there's no schema for those properties, each entry's memory footprint is larger.</p>
        <h3>In-place Schema Evolution with Downtime</h3>
        <p>This approach is to undeploy the <MadCap:variable name="General.ProductNameXAP" />service, modify the schema in the external database, and then re-deploy the <MadCap:variable name="General.ProductNameXAP" /> service. This will initial-load the modified schema and data.</p>
        <p>This results in an efficient footprint in memory, but requires some downtime while the data store is being copied.</p>
        <h3><MadCap:variable name="General.SchemaEvolutionWithoutDowntime" />
        </h3>
        <p><MadCap:variable name="General.SchemaEvolutionWithoutDowntime" /> can make the process of changing a fixed schema efficient and painless.</p>
        <p><MadCap:variable name="General.SchemaEvolutionWithoutDowntime" /> works by creating a mirror service and copying the original space (V1) to the new space (V2). The copying process is done via a Kafka messaging layer and does not require the Space or stateful services that use the Document Store to be offline. Note that the V1 and V2 spaces co-exist side-by-side. External users are redirected to the new service, and the old service is closed. </p>
        <p>The schema evolution process copies each entry from the V1 object to the V2 object. A Type Adapter  - a function which transforms V1 to V2  -  performs the necessary conversion of the schema, on an entry-by-entry basis, as shown in the following diagram: </p>
        <p>
            <img src="../Resources/Static/images/SEWD overview.jpg" />
        </p>
        <ol>
            <li>Client interacts with stateful service (i.e. service that contains a space).</li>
            <li>Data changes from space V1 are mirrored into database with schema V1.</li>
            <li>Data changes are streamlined into service V2, using a user-defined Type Adapter.</li>
            <li>Client interacts with service V2.</li>
            <li>Data changes from space V2 are mirrored into database with schema V2.</li>
        </ol>
        <p>While the copying process is underway, all requests are logged for later processing with the new V2 object. No data is lost. There is no downtime and no requirement to make the space offline.</p>
        <p>Because <MadCap:variable name="General.SchemaEvolutionWithoutDowntime" /> makes online changes to a fixed-schema object, the object’s schema can be updated from time to time -- providing much of the flexibility of a Space Document.</p>
        <p>The resulting object has all of the advantages of a fixed schema -- optimal read/write processing and minimal memory footprint -- without a need for the system to interpret dynamic fields.</p>
        <h3>Schema Changes Allowed with <MadCap:variable name="General.SchemaEvolutionWithoutDowntime" /></h3>
        <p>The following types of changes can be performed:</p>
        <ul>
            <li>Add a new field</li>
            <li>Remove an existing field</li>
            <li>Change the field type of an existing field</li>
        </ul>
        <h3>When is <MadCap:variable name="General.SchemaEvolutionWithoutDowntime" /> the Right Approach?</h3>
        <p><MadCap:variable name="General.SchemaEvolutionWithoutDowntime" /> is a powerful tool to use in your production environment  when the following requirements are important in your system:</p>
        <ul>
            <li>Occasional changes to an object’s fixed schema.</li>
            <li>No down time -- during the <MadCap:variable name="General.SchemaEvolutionWithoutDowntime" /> process, all services and processes using the object continue to run.</li>
            <li>Optimal read/write access after the schema change, with minimal memory footprint</li>
            <li>Support for various services deployments strategies for A/B testing and gradual deployment of new services and versions</li>
        </ul>
        <h2>Options for Schema Evolution are summarized below:</h2>
        <table>
            <tr>
                <td><b>Type of data in the Data Store</b>
                </td>
                <td><b>Meaning</b>
                </td>
                <td><b>Procedure for Schema Evolution</b>
                </td>
                <td><b>Resources allocation during the schema transformation</b>
                </td>
                <td><b>Resulting memory footprint of the properties</b>
                </td>
                <td><b>Requires downtime</b>
                </td>
                <td><b>Schema strategy</b>
                </td>
                <td><b>Schema Transformation duration</b>
                </td>
                <td><b>Data transformation</b>
                </td>
                <td><b>Index functionality</b>
                </td>
            </tr>
            <tr>
                <td>Dynamic properties only </td>
                <td>Define a data store that has dynamic, schema-on-read properties</td>
                <td>Option A: No special procedure - Just change the dynamic properties for the data store</td>
                <td>Low</td>
                <td>Relatively high</td>
                <td>No</td>
                <td>In place</td>
                <td>Immediate</td>
                <td>null fields by default to v1,v2 holds the new schema</td>
                <td>only equality index, no range index</td>
            </tr>
            <tr>
                <td rowspan="2">Fixed properties only</td>
                <td rowspan="2">Define a data store that has fixed, schema-on-write properties</td>
                <td>Option B: Recreate the data store.Time-consuming -- undeploy the data store and any PUs that use the data store; modify the schema; redeploy</td>
                <td>High</td>
                <td>Relatively low</td>
                <td>Yes</td>
                <td>In place</td>
                <td>Dependent on the space size and network bandwidth to the external DB</td>
                <td>all v1 is transformed to v2</td>
                <td>any index</td>
            </tr>
            <tr>
                <td>Option C: <b>Side-by-Side Schema Evolution.</b>Create a new data store without downtime.</td>
                <td>Double the normal memory and CPU requirements</td>
                <td>Relatively low</td>
                <td>No</td>
                <td>side by side</td>
                <td>Minutes to hours</td>
                <td>all v1 is transformed to v2</td>
                <td>any index</td>
            </tr>
            <tr>
                <td>Hybrid -- both fixed and dynamic properties</td>
                <td>Define a data store that has some fixed properties, and some dynamic properties</td>
                <td colspan="8">If you are changing only dynamic properties, proceed as Option A above.If you are changing fixed properties, or both kinds of properties, proceed as Option B or Option C above.</td>
            </tr>
        </table>
        <h3>Installation Requirements and Considerations for <MadCap:variable name="General.SchemaEvolutionWithoutDowntime" /></h3>
        <p><MadCap:variable name="General.SchemaEvolutionWithoutDowntime" /> is currently available for Space Documents. Support for Space Objects will be added in a future release.</p>
        <p>Since <MadCap:variable name="General.SchemaEvolutionWithoutDowntime" /> uses Kafka as the data messaging layer, the user must provide their own Kafka cluster. We require the Kafka connection string of the user’s existing Kafka installation.</p>
        <p><MadCap:variable name="General.SchemaEvolutionWithoutDowntime" /> is currently implemented for in-memory Space Objects. MemoryXtend will be supported in a future release.</p>
        <p>Capacity planning should include the CPU and RAM resources to accommodate both spaces, V1 and V2 side-by-side during the Schema Evolution process.</p>
        <p>Kafka considerations:</p>
        <ul>
            <li>Kafka buffer size</li>
            <li>Number of threads</li>
            <li>Deployment Strategy</li>
        </ul>
        <p>During the Schema Evolution process, all data requests are logged.</p>
        <h3>How to Implement <MadCap:variable name="General.SchemaEvolutionWithoutDowntime" /></h3>
        <p>The steps to run <MadCap:variable name="General.SchemaEvolutionWithoutDowntime" /> are as follows:</p>
        <ul>
            <li>Determine the schema changes that are required.</li>
            <li>Create a Type Adapter object with the data conversion rules</li>
            <li>Generate a JAR file from the patcher program</li>
            <li>Define the connection to Kafka.</li>
            <li>Perform the client sync. Note that because the first operation will fail and throw an exception, the user must provide custom code to handle the exception.</li>
            <li>Xxxxx</li>
            <li>Xxxxx</li>
        </ul>
        <h3>Hands/on example of <MadCap:variable name="General.SchemaEvolutionWithoutDowntime" /></h3>
        <p>xxxxxxxxxxxxxxxxxxxxxxxx</p>
        <p>&#160;</p>
    </body>
</html>