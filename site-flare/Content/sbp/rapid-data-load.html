<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
<head></head>
<body>
<h1>Rapid Data Load</h1>
  

<table>
<thead>
<tr>
<th>Author</th>
<th>XAP Version</th>
<th>Last Updated</th>
<th>Reference</th>
<th>Download</th>
</tr>
</thead>

<tbody>
<tr>
<td>Shay Hassidim</td>
<td>7.0</td>
<td>July 2009</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

<h1><a name="overview">&#160;</a>Overview</h1>

<p>In some cases you might need to load data into the data grid in a very fast manner. This is mostly needed as part of your development phase or unit tests. You might not have a fast database on hand to load data, from using the <a href="/xap/14.0/dev-java/space-persistency-initial-load.html">HibernateExternalDataSource</a> implementation, or it might be easier for you to create a data generator utility that simulates the real life data your application needs. A simple technique to load data very rapidly into the data grid, is to use a <a href="/xap/14.0/dev-java/executor-based-remoting.html">DistributedTask</a> implementation that generates the data and writes it into the collocated space. The generated data is constructed in such a way that its routing field value "matches" the collocated space.</p>

<p><img src="/attachment_files/sbp/rapid_data_load.jpg" alt="rapid_data_load.jpg" />
The Distributed Task is executed for each Space class you have, allowing you to load data in a parallel manner across all partitions (this is in fact 2 dimensional parallel data load).</p>

<h1><a name="example">&#160;</a>Example</h1>

<p>Here is a simple example: we have 3 types of Space Classes:
<code>StockMktHist</code>, <code>LastPrice</code>, <code>StockHist</code> - all of these use the <code>Currency</code> field as their routing field. The Currency routing field is a string-based field, where its values could be USD,EUR,GBP, etc.</p>

<h2><a name="the-createcurrencygroups">&#160;</a>The createCurrencyGroups</h2>

<p>A Data generator utility class has a <code>createCurrencyGroups()</code> method that generates a Hash Map that groups currencies that belong to the same partition using the Currency String hashcode - here is a simple implementation of such a method:</p>

<pre><code class="language-java">static String currencies[] = { "AFN","ALL","AMD","ANG","AOA","ARS","AUD","AWG","AZN","BAM","BBD",
"BDT","BGN","BHD","BIF","BMD","BND","BOB","BRL","BSD","BTN",
    "BWP","BYR","BZD","CAD","CVE","DZD","EUR","GBP","INR","KHR",
    "KYD","MMK","NOK","USD","XAF","XCD","XOF" };

public static void createCurrencyGroups(int maxPartitions) {
    if (currencyGroups != null )
        return;
    currencyGroups = new ConcurrentHashMap&lt;Integer,List &lt;String&gt; &gt;();

    for (String  currency: currencies) {
        int group = currency.hashCode() % maxPartitions;
        if (!currencyGroups.containsKey(group))
        {
            currencyGroups.put(group , new ArrayList&lt;String&gt;());
        }
        currencyGroups.get(group).add(currency);
    }
}
</code></pre>

<p>With the above implementation, we generate several lists of currencies, all of these are maintained within <code>currencyGroups</code> - one for each partition.</p>

<h2><a name="the-getrandomcurrency">&#160;</a>The getRandomCurrency</h2>

<p>The Data generator also has the <code>getRandomCurrency</code> method that returns a random currency, based on a given partition - it uses the currencyGroups we created above:</p>

<pre><code class="language-java">public static String getRandomCurrency(int partition) {

    // for a Single space
    if (partition ==0)
        return currency[random.nextInt(currency.length)];

    List&lt;String&gt; list = currencyGroups.get(partition-1);
    return list.get (random.nextInt(list.size()));
}
</code></pre>

<p>The getRandomCurrency is used with our data generator utility.</p>

<h2><a name="the-loaderrequest">&#160;</a>The LoaderRequest</h2>

<p>The LoaderRequest execute method implementation generates an array of the requested type and writes it using one method call (writeMultiple) into its collocated space:</p>

<pre><code class="language-java">public class LoaderRequest implements DistributedTask&lt;String, String&gt;{

    public static final int RequestTypeLastPrice =1;
    public static final int RequestTypeStockHist=2;
    public static final int RequestTypeStockMktHist=3;

    @TaskGigaSpace
    transient GigaSpace gigaspace;

    transient static int batchSize = 5000;

    transient int partition ;
    transient int maxPartitions ;

    int amount;
    int requestType;

    public LoaderRequest (int amount ,  int requestType)
    {
        this.amount=amount;
        this.requestType=requestType;
    }

    @Override
    public String execute() throws Exception {
        System.out.println(System.currentTimeMillis() + " " +
                Thread.currentThread().getName() + "-------&gt; Loading Data into Partition:"
                +gigaspace.getSpace().getURL().getMemberName() + " - requestType:"+ requestType);

        // for a single space
        if (gigaspace.getSpace().getURL().getProperty(SpaceURL.CLUSTER_SCHEMA) == null)
        {
            partition =1;
            maxPartitions =1;
        }
        else
        {
            partition  = Integer.valueOf(gigaspace.getSpace().getURL().getProperty(SpaceURL.CLUSTER_MEMBER_ID)).intValue();
            maxPartitions = Integer.valueOf(gigaspace.getSpace().getURL().getProperty(SpaceURL.CLUSTER_TOTAL_MEMBERS)).intValue();
        }

        DataGenerator.createCurrencyGroups(maxPartitions);

        LastPrice lastPriceBatch[] = null;
        StockHist stockHistBatch[] = null ;
        StockMktHist stockMktHistBatch[]= null;
        switch (requestType) {
        case RequestTypeLastPrice :
        {
            lastPriceBatch = new LastPrice [batchSize ];
            break;
        }
        case RequestTypeStockHist:
        {
            stockHistBatch = new StockHist [batchSize ];
            break;
        }
        case RequestTypeStockMktHist :
        {
            stockMktHistBatch = new StockMktHist [batchSize ];
            break;
        }
        default:
            {
            System.out.println(" ========= Non supported type ========= ");
                break;
            }
        }
        int cycles= amount/batchSize;
        for (int i=0;i&lt;cycles;i++)
        {
            switch (requestType) {
                case RequestTypeLastPrice :
                {
                    for (int j=0;j&lt;batchSize;j++)
                    {
                        lastPriceBatch[j]=DataGenerator.createLastPrice(partition);
                    }
                    gigaspace.writeMultiple(lastPriceBatch);
                    break;
                }
                case RequestTypeStockHist:
                {
                    for (int j=0;j&lt;batchSize;j++)
                    {
                        stockHistBatch[j]=DataGenerator.createStockHist(partition);
                    }
                    gigaspace.writeMultiple(stockHistBatch);
                    break;
                }
                case RequestTypeStockMktHist :
                {
                    for (int j=0;j&lt;batchSize;j++)
                    {
                        stockMktHistBatch[j] = DataGenerator.createStockMktHist(partition);
                    }
                    gigaspace.writeMultiple(stockMktHistBatch);
                    break;
                }
            }
        }
        return "OK";
    }

    @Override
    public String reduce(List&lt;AsyncResult&lt;String&gt;&gt; result) throws Exception {
        return "OK";
    }

    int routing;

    @SpaceRouting
    public Integer routing() {
        return routing;
    }

}
</code></pre>

<h2><a name="the-client-application">&#160;</a>The Client Application</h2>

<p>The client application creates a <code>LoaderRequest</code> object and executes it, one for each space Class, where in reality all these <code>LoaderRequest</code> objects are sent in parallel to all running partitions to be executed. This is how you have these 3 types of objects loaded into all partitions simultaneously:</p>

<pre><code class="language-java">GigaSpace gigaSpace = new GigaSpaceConfigurer(new UrlSpaceConfigurer("jini://*/*/space").space()).gigaSpace();
AsyncFuture&lt;String&gt; future1 = gigaSpace.execute(new LoaderRequest(objectsToLoad,LoaderRequest.RequestTypeLastPrice));
AsyncFuture&lt;String&gt; future2 = gigaSpace.execute(new LoaderRequest(objectsToLoad,LoaderRequest.RequestTypeStockHist));
AsyncFuture&lt;String&gt; future3 = gigaSpace.execute(new LoaderRequest(objectsToLoad,LoaderRequest.RequestTypeStockMktHist));
String result1 = future1.get();
String result2 = future2.get();
String result3 = future3.get();
</code></pre>

</body>
</html>