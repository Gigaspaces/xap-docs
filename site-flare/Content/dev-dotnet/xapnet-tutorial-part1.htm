<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
<head></head>
<body>
<h1>Interacting with the Space</h1>
  

<p>In this part of the tutorial we will demonstrate how to create a Space and how you can interact with it. We will also demonstrate how you can improve your Space search performance by using indexes and returning partial results.</p>

<h1 id="creating-a-space">Creating a Space</h1>

<p>Let's create a Space called "xapTutorialSpace' that is co-located within an application. This type of Space is called embedded Space.</p>

<p>Here is an example how you start an embedded Space:</p>

<pre><code class="language-csharp">using GigaSpaces.Core;

// Create the SpaceProxy
ISpaceProxy spaceProxy = new EmbeddedSpaceFactory("xapTutorialSpace").Create();
</code></pre>

<p>This Space we just created can also be accessed remotely from another application. In order to do so you would use the following code:</p>

<pre><code class="language-csharp">ISpaceProxy spaceProxy = new SpaceProxyFactory("xapTutorialSpace").Create();
</code></pre>

<p>You can configure the Space URL with several options.</p>

<div class="tc-admon-refer">
  
  <p><a href="../dev-dotnet/the-space-configuration.htm/">The Space Configuration</a></p>
</div>

<p>When a client connects to a Space, a proxy is created that holds a connection which implements the Space API. All client interaction is performed through this proxy.</p>

<p>With XAP you can also create a Local Cache and a Local View.</p>

<ul>
<li>Local Cache : This client side cache maintains any object used by the application. The cache data is loaded on demand (lazily), based on the client application's read operations.</li>
<li>Local View  : This client side cache maintains a specific subset of the data. The subset is predefined by the user. The cache is populated when the client application is started.
In both cases, updates are performed (objects are added/updated/removed) on the master Space, the master Space then propagates the changes to all relevant local views and caches.</li>
</ul>

<p>These two scenarios are only applicable for remote clients.</p>

<div class="tc-admon-refer">
  
  <p><a href="../dev-dotnet/client-side-caching.htm/">Client Side Caching</a></p>
</div>

<h1 id="the-space-object">The Space Object</h1>

<p>XAP supports two types of objects that can interact with the Space, PONOs and Documents.</p>

<h1 id="pono">PONO</h1>

<p>Any PONO can be used to interact with the Space. The PONO needs to implement a default constructor, setters and getters for every property you want to store in the Space.</p>

<pre><code class="language-csharp">using System;
using System.Collections.Generic;

using GigaSpaces.Core.Metadata;

    public class User {

        [SpaceID(AutoGenerate = false)]
        [SpaceRouting]
        public long? Id { set; get; }
        public String Name{ set; get; }
        public double? Balance{ set; get; }
        public double? CreditLimit{ set; get; }
        public Nullable&lt;EAccountStatus&gt; Status{ set; get; }
        public Address Address{ set; get; }
        public String[] Comment{ set; get; }
        public Dictionary&lt;String, String&gt; Contacts{ set; get; }
        public List&lt;Group&gt; Groups{ set; get; }
        public List&lt;int?&gt; Ratings{ set; get; }

        //.....
    }
}
</code></pre>

<h4 id="the-spaceid">The SpaceId</h4>

<p>The Space generates a unique identifier (UID) for every object in one of the following ways:</p>

<ul>
<li>When a Space object has no SpaceId attribute declared, the Space auto-generates a UID for the object.</li>
<li>When a Space object has an attribute which is declared as SpaceId and marked as auto-generate=false, the UID is generated based on the value of the ID attribute the user is setting.</li>
<li>When a Space object has an attribute which is declared as SpaceId and marked as auto-generate=true, the UID is generated by the Space and placed back into the attribute using the relevant setter method. In this case, the attribute must be of String type.</li>
</ul>

<div class="tc-admon-refer">
  
  <p><a href="../dev-dotnet/poco-object-id.htm/">Space Object Id</a></p>
</div>

<h4 id="defining-routing">Defining Routing</h4>

<p>Partitioning is used when the total number of objects is too big to be stored in a single Space. In this case we will divide the data into several partitions. By designating an attribute on the Space class as a partitioning key, the Space proxy will then know to which partition a particular instance of the Space class belongs to. The Space proxy uses the entry's routing attribute hash code to determine the corresponding partition for it.</p>

<div class="tc-admon-note">
  
  <p>The routing attribute can be explicitly set using the <code>[SpaceRouting]</code> annotation for PONO entries or via the SpaceTypeDescriptorBuilder for document entries. If the routing attribute is not explicitly set, the Space id attribute is used for routing. If the Space id attribute is not defined, the first indexed attribute (alphabetically) is used for routing, otherwise the first attribute (alphabetically) is used for routing.</p>
</div>

<div class="tc-admon-refer">
  
  <p><a href="../admin/data-partitioning.htm/">Data Partitioning</a></p>
</div>

<h1 id="space-document">Space Document</h1>

<p>The XAP document API exposes the Space as Document Store. A document, which is represented by the class SpaceDocument, is essentially a collection of key-value pairs, where the keys are strings and the values are primitives, String, Date, other documents, or collections thereof. Unlike PONOs, which force users to design a fixed data schema (in the form of a class definition) and adhere to it, a document is much more dynamic, users can add and remove properties at runtime as necessary. A Document always belongs to a certain type, represented by the class SpaceTypeDescriptor.</p>

<p>To create a document we use a Dictionary&lt;String,Object&gt; for its properties. The SpaceDocument object is instantiated by using the type name and properties. XAP provides a special implementation of a Dictionary called  DocumentProperties.</p>

<p>Here is an example how you can create a SpaceDocument:</p>

<pre><code class="language-csharp">using System;

using GigaSpaces.Core;
using GigaSpaces.Core.Document;
using GigaSpaces.Core.Metadata;

namespace xaptutorial.model
{
    public SpaceDocument createDocumemt() {
        DocumentProperties properties = new DocumentProperties ();

        properties["CatalogNumber"]= "av-9876";
        properties["Category"]= "Aviation";
        properties["Name"] = "Jet Propelled Pogo Stick";
        properties["Price"]= 19.99;
        properties["Tags"]= new String[4] {"New", "Cool", "Pogo", "Jet"};

        DocumentProperties p2 = new DocumentProperties();
        p2["Manufacturer"]="Acme";
        p2["RequiresAssembly"]=true;
        p2["NumberOfParts"]= 42;
        properties["Features"]=p2;

        SpaceDocument document = new SpaceDocument("Product", properties);
        proxy.Write(document);

        return document;
    }
}
</code></pre>

<p>In order to use the SpaceDocument, we need to register its schema first with the Space:</p>

<pre><code class="language-csharp">public void registerProductType() {
    // Create type Document descriptor:
    SpaceTypeDescriptorBuilder typeBuilder = new SpaceTypeDescriptorBuilder("Product");
    typeBuilder.SetIdProperty("CatalogNumber");
    typeBuilder.SetRoutingProperty("Category");
    typeBuilder.AddPathIndex("Name");
    typeBuilder.AddPathIndex("Price", SpaceIndexType.Extended);
    ISpaceTypeDescriptor typeDescriptor = typeBuilder.Create();

    // Register type:
    proxy.TypeManager.RegisterTypeDescriptor(typeDescriptor);
}
</code></pre>

<p>Only properties with special roles like ID and Routing are part of the schema definition. These meta model settings cannot be changed without restarting the Space or dropping the type, clearing all its instances and reintroducing it again.</p>

<div class="tc-admon-note">
  
  <p>It is possible to write a PONO to the Space and read it back as a document, and vice versa. This scenario is useful when you want to read or modify PONO objects without loading the concrete C# classes.</p>
</div>

<div class="tc-admon-refer">
  
  <p><a href="../dev-dotnet/document-object-interoperability.htm/">Document Object Interoperability</a></p>
</div>

<h1 id="interacting-with-the-space">Interacting with the Space</h1>

<p>All Space operations are relevant to both the PONO and Document.</p>

<h4 id="writing-an-object-to-space">Writing an object to Space:</h4>

<p>When writing an object to the Space, the object is created in Space if it does not exist. If it already exists in Space it will be updated. This is the default behavior of the write operation.</p>

<pre><code class="language-csharp">public void writeUser() {
     User user = new User();
     user.Id= 1L;
     user.Name="John Smith";
     user.Status=EAccountStatus.ACTIVE;

     // Write the user to the Space
     spaceProxy.Write(user);
}
</code></pre>

<p>It is also possible to write multiple objects in one operation to the Space (batch mode). This can vastly improve the performance if you need to load many objects at once into the Space.</p>

<p>Here is an example on how you write multiple objects to the Space:</p>

<pre><code class="language-csharp">public void writeUsers() {
     User[] users = new User[2];
     users[0] = new User();
     users[0].Id=1L;
     users[0].Name="John Doe";
     users[0].Status=EAccountStatus.ACTIVE;

     users[1] = new User();
     users[1].Id=2L;
     users[1].Name="John Doe";
     users[1].Status=EAccountStatus.ACTIVE;

     spaceProxy.WriteMultiple(users);
}
</code></pre>

<p>There are several options to override the default behavior of the write operation. You can change the lifetime of an object by supplying a LEASE to the operation. You can also change the modifier on the operation to change the behavior.</p>

<p>Here is an example:</p>

<pre><code class="language-csharp">public void writeOnlyWithLease() {
    User user = new User();
    user.Id=1L;
    user.Name="John Smith";
    user.Status=EAccountStatus.ACTIVE;

    // no transaction and 10 seconds lease time
    proxy.Write(user,null,0,10000, WriteModifiers.WriteOnly);
}
</code></pre>

<p>In this example, we are writing an object to the Space with zero delay, 10 seconds to live and write only if the object does not already exist in the Space. If the object already exists, an exception will be thrown.</p>

<div class="tc-admon-refer">
  
  <p><a href="../dev-dotnet/the-space-operations.htm/">The Space Operations</a></p>
</div>

<h4 id="updating-an-object-in-space">Updating an object in Space</h4>

<p>When you want to update only a couple of attributes on an object in Space, you can use the change operation and update specific fields or even nested fields or modify collections and maps without having to supply the entire collection or map for the operation. With the following change operation example it is not necessary to read the object first from the Space to update it. The Change API reduces a normal two step operation to a one step operation. This operation can vastly improve performance when you have an object with many attributes and you only need to update one or a couple of attributes.</p>

<pre><code class="language-csharp">public void changeSet() {
    User user = new User();
    user.Id=1L;
    user.Name="John Doe";
    user.Status=EAccountStatus.ACTIVE;
    proxy.Write(user);

    IdQuery&lt;User&gt; idQuery = new IdQuery&lt;User&gt;(1L);
    IChangeResult&lt;User&gt; changeResult =
        proxy.Change&lt;User&gt;(idQuery,
        new ChangeSet().Set("Status", EAccountStatus.BLOCKED));

    if (changeResult.NumberOfChangedEntries == 0) {
        Console.WriteLine("Entry does not exist");
    }
}
</code></pre>

<p>There are several other change operations available; "increment', "decrement', "addToCollection', "removeFromCollection' etc.</p>

<div class="tc-admon-refer">
  
  <p><a href="../dev-dotnet/change-api-overview.htm/">The Change API</a></p>
</div>

<h1 id="querying-the-space">Querying the Space</h1>

<p>Now we are ready to query the Space. XAP provides several ways to perform queries against the Space:</p>

<ul>
<li>Query by ID</li>
<li>Query by Template</li>
<li>Query by SQL</li>
</ul>

<h4 id="query-by-id">Query by ID</h4>

<p>This is the simplest and fasted way to retrieve objects from the Space.</p>

<p>Here is an example of a query by id:</p>

<pre><code class="language-csharp">public User findUserById() {
    return proxy.ReadById&lt;User&gt;(1L);
}
</code></pre>

<p>You can also perform a bulk read for multiple Id's</p>

<pre><code class="language-csharp">public User[] findUsersByIds() {
    object[] ids  = new object[3]{ 1L, 2L, 3L };

    IReadByIdsResult&lt;User&gt; result = proxy.ReadByIds&lt;User&gt;(ids);
    return result.ResultsArray;
}
</code></pre>

<h4 id="query-by-template">Query by Template</h4>

<p>Template matching (match by example) is a simple way to query the Space. The template is a PONO of the desired entry type, and the attributes which are set on the template (i.e. not null) are matched against the respective attributes of entries of the same type in the Space. Attributes with null values are ignored (not matched).</p>

<p>The following examples assume the default constructor of the User class initializes all its attributes to null.</p>

<p>Read an entry of type User where the name is "John Doe':</p>

<pre><code class="language-csharp">public User findUserByTemplate() {
    User user = new User();
    user.Name="John Doe";
    return proxy.Read(user);
}
</code></pre>

<p>You can also perform a bulk read with templates. In the example below will read all users that have a status of ACTIVE:</p>

<pre><code class="language-csharp">public User[] findUsersByTemplate() {
    User user = new User();
    user.Status=EAccountStatus.ACTIVE;
    return proxy.ReadMultiple(user);
}
</code></pre>

<div class="tc-admon-note">
  
  <p>Template Matching support inheritance relationships, so that entries of a sub-class are visible in the context of the super class, but not the other way around.</p>
</div>

<h4 id="sql-query">SQL Query</h4>

<p>The SQLQuery class is used to query the Space with an SQL-like syntax. The query statement includes only the WHERE statement part. An SQLQuery is composed from the class of entry to query and an expression in SQL syntax.</p>

<pre><code class="language-csharp">public User[] sqlFindUsersByName() {
    SqlQuery&lt;User&gt; query = new SqlQuery&lt;User&gt;("Name = 'John Doe'");
    return proxy.ReadMultiple&lt;User&gt;(query);
}

public User[] sqlFindUsersByNameAndCreditLimit() {
    SqlQuery&lt;User&gt; query = new SqlQuery&lt;User&gt;("Name = 'John Doe' AND CreditLimit &gt; 1000");
    return proxy.ReadMultiple&lt;User&gt;(query);
}

public User[] sqlFindUsersByNameAndIds() {
    SqlQuery&lt;User&gt; query = new SqlQuery&lt;User&gt;( "Name = 'John Doe' AND Id IN(1L,3L,5L)");
    return proxy.ReadMultiple&lt;User&gt;(query);

public User[] sqlFindUsersByNameLike() {
    SqlQuery&lt;User&gt; query = new SqlQuery&lt;User&gt;("Name like 'A%'");
    return proxy.ReadMultiple&lt;User&gt;(query);

}
</code></pre>

<h4 id="parameterized-queries">Parameterized Queries</h4>

<p>You can separate the values for the SQL criteria expression by placing a "?' symbol instead of the actual value in the expression. When executing the query, the conditions that includes "?' are replaced with the corresponding parameter values supplied via the setParameter  method.</p>

<p>For example:</p>

<pre><code class="language-csharp">public User[] sqlParameterFindUsersByName() {
    SqlQuery&lt;User&gt; query = new SqlQuery&lt;User&gt;("Name = ?")
    query.SetParameter(1, "John Doe");
    return proxy.ReadMultiple&lt;User&gt;(query);
}

public User[] sqlParameterFindUsersByNameAndCreditLimit() {
    SqlQuery&lt;User&gt; query = new SqlQuery&lt;User&gt;("Name = ? AND CreditLimit &gt; ?");
    query.SetParameter(1, "John Doe");
    query.SetParameter(2, 1000);
    return proxy.ReadMultiple&lt;User&gt;(query);
}
</code></pre>

<h4 id="nested-property-queries">Nested property queries</h4>

<p>Many times a class has embedded classes as attributes. You can query for attributes within the embedded classes. Matching a nested attribute is done by specifying a Path which describes how to obtain its value. For example, our user class has an embedded attribute of an Address that has a zipCode attribute.</p>

<div class="tc-admon-note">
  <p class="tc-admon-title">Nested Objects</p>
  <p>By default, nested objects are kept in a binary form inside the Space. In order to support nested matching, the relevant property should be stored as document, or as object if it is in an interoperability scenario and it has a corresponding Java class.</p>
</div>

<div class="tc-admon-refer">
  
  <p><a href="../dev-dotnet/poco-storage-type.htm/">Object Storage Types</a></p>
</div>

<p>Here is an example how you would annotate a class to enable nested queries:</p>

<pre><code class="language-csharp">    public class User {

        [SpaceID(AutoGenerate = false)]
        [SpaceRouting]
        public long? Id { set; get; }

        public String Name{ set; get; }
        public double? Balance{ set; get; }
        public double? CreditLimit{ set; get; }
        public Nullable&lt;EAccountStatus&gt; Status{ set; get; }

        [SpaceProperty(StorageType = StorageType.Document)]
        public Address Address{ set; get; }
        public String[] Comment{ set; get; }

        [SpaceProperty(StorageType = StorageType.Document)]
        public Dictionary&lt;String, String&gt; Contacts{ set; get; }

        [SpaceProperty(StorageType = StorageType.Document)]
        public List&lt;Group&gt; Groups{ set; get; }

        [SpaceProperty(StorageType = StorageType.Document)]
        public List&lt;int?&gt; Ratings{ set; get; }

        //......
    }
}
</code></pre>

<p>Here is an example how you can query the Space for all users that have a zip code of "12345'.</p>

<pre><code class="language-csharp">public User[] sqlFindUsersByZipCode() {
    SqlQuery&lt;User&gt; query = new SqlQuery&lt;User&gt;("Address.ZipCode = 12345");
    return proxy.ReadMultiple&lt;User&gt;(query);
}
</code></pre>

<h4 id="nested-collections">Nested Collections</h4>

<p>It is possible to query embedded collections. Our user class has a collection groups that he belongs to. We can query the Space for all users that belong to a certain group:</p>

<pre><code class="language-csharp">public User[] findUsersByGroup() {
    SqlQuery&lt;User&gt; sqlQuery = new SqlQuery&lt;User&gt;( "Groups[*].Id = 1");
    return proxy.ReadMultiple&lt;User&gt;(sqlQuery);
}
</code></pre>

<p>There are several additional query options available. For example you can query Nested Maps by key,query with Regular Expression, Enum attributes and others.</p>

<div class="tc-admon-refer">
  
  <p><a href="../dev-dotnet/query-sql.htm/">SQL Query</a></p>
</div>

<h4 id="query-returning-partial-results">Query returning partial results</h4>

<p>In some cases when querying the Space for objects only specific attributes of an objects are required and not the entire object (delta read). For that purpose the Projection API can be used where you can specify which attributes are of interest and the Space will only populate these attributes with the actual data when the result is returned back to the user. This approach reduces network overhead and can vastly improve performance.</p>

<p>In this example below we are just interested in the name attribute of the user object:</p>

<pre><code class="language-csharp">public User[] findUsersByNameAndProjection() {
    SqlQuery&lt;User&gt; query = new SqlQuery&lt;User&gt;( "Name = ?"){Projections = new []{"Name"}};
    query.SetParameter (1, "John Doe");

    return proxy.ReadMultiple&lt;User&gt;(query);
}
</code></pre>

<h4 id="document-queries">Document Queries</h4>

<p>You can also query the Space for documents. Just like the PONO queries, you can use query by ID, template and SQLQuery.</p>

<p>Here are some examples how you can query the Space for documents:</p>

<pre><code class="language-csharp">public SpaceDocument readProductById() {
    SpaceDocument template = new SpaceDocument("Product");
    template["CatalogNumber"]= "av-9876";
    return proxy.Read(template);
}

public SpaceDocument readProductByTemplate() {
    SpaceDocument template = new SpaceDocument("Product");
    template["Name"]= "Jet Propelled Pogo Stick";
    return proxy.Read(template);
}

public SpaceDocument[] readProductsBySQL() {
    SqlQuery&lt;SpaceDocument&gt; query = new SqlQuery&lt;SpaceDocument&gt;("Product","Price &gt; ?");
    query.SetParameter(1, 15.0);
    return proxy.ReadMultiple&lt;SpaceDocument&gt;(query);
}
</code></pre>

<div class="tc-admon-refer">
  
  <p><a href="../dev-dotnet/document-api.htm/">The Document API</a></p>
</div>

<h4 id="linq-queries">LINQ Queries</h4>

<p>XAP includes a custom LINQ provider, which enables developers to take advantage of their existing C# skills to query the Space without learning a new language.  Here is an example :</p>

<pre><code class="language-csharp">using GigaSpaces.Core.Linq;

   var query = from p in spaceProxy.Query&lt;Account&gt;()
            where p.number == "12345"
            select p;

   foreach (var account in query)
   {
    // ...
   }
</code></pre>

<div class="tc-admon-refer">
  
  <p><a href="../dev-dotnet/query-linq.htm/">LINQ Query</a></p>
</div>

<h4 id="removing-objects-from-space">Removing Objects from Space</h4>

<p>To remove objects from a Space you can use the take or the clear operation.</p>

<h4 id="take-operation">Take operation</h4>

<p>The take operation returns an object and removes it from the Space. XAP provides several options for the take operation:</p>

<ul>
<li>Take by ID</li>
<li>Take by template</li>
<li>Take by SQLQuery</li>
<li>Take multiple</li>
</ul>

<p>Here are some examples:</p>

<pre><code class="language-csharp">public User takeUserById() {
   return spaceProxy.TakeById&lt;User&gt;(1L);
}

public User takeUserByTemplate() {
   User template = new User();
   template.Name="John Doe";
   return spaceProxy.Take&lt;User&gt;(template);
}

public User[] takeUsersBySQL() {
     SqlQuery&lt;User&gt; query = new SqlQuery&lt;User&gt;("Status = ?");
     query.setParameter(1, EAccountStatus.BLOCKED);
   return spaceProxy.TakeMultiple&lt;User&gt;(query);
}
</code></pre>

<h4 id="clear-operation">Clear operation</h4>

<p>The clear operation removes objects from a Space without returning them.
Here are some examples:</p>

<pre><code class="language-csharp">public void clearUserByTemplate() {
     User template = new User();
     spaceProxy.Clear(template);
}

public void clearUserBySQL() {
     SqlQuery&lt;User&gt; query = new SqlQuery&lt;User&gt;(User.class, "Name = ?");
     query.setParameter(1, "John Doe");
     spaceProxy.Clear(query);
}

// clear all objects in space
public void clearAllObjectInSpace() {
     spaceProxy.Clear(null);
}
</code></pre>

<h4 id="aggregation">Aggregation</h4>

<p>The Aggregators allow you to perform the entire aggregation activity at the Space side avoiding any data retrieval back to the client side. Only the result of each aggregation activity performed with each partition is returned back to the client side where all the results are reduced and returned to the client application.</p>

<pre><code class="language-csharp">using GigaSpaces.Core.Linq;

...
var queryable = from p in spaceProxy.Query&lt;Person&gt;("Country='UK' OR Country='U.S.A'") select p;
// retrieve the maximum value stored in the field "age"
int maxAgeInSpace = queryable.Max(p =&gt; p.Age);
// retrieve the minimum value stored in the field "age"
int minAgeInSpace = queryable.Min(p =&gt; p.Age);
// Sum the "age" field on all space objects.
int combinedAgeInSpace = queryable.Sum(p =&gt; p.Age);
// Sum's the "age" field on all space objects then divides by the number of space objects.
double averageAge = queryable.Average(p =&gt; p.Age);
// Retrieve the space object with the highest value for the field "age".
Person oldestPersonInSpace = queryable.MaxEntry(p =&gt; p.Age);
// Retrieve the space object with the lowest value for the field "age".
Person youngestPersonInSpace = queryable.MinEntry(p =&gt; p.Age);

</code></pre>

<p>XAP also supports, <code>Compound</code> and <code>Embedded Fields</code>   Aggregation.</p>

<div class="tc-admon-refer">
  
  <p><a href="../dev-dotnet/aggregators.htm/">Aggregators</a></p>
</div>

<h1 id="indexing">Indexing</h1>

<p>To improve performance, it is possible to index one or more attributes for an object. The Space maintains additional data for indexed attributes, which shortens the time required to determine a match resulting in improved performance. However, indexes consume more resources and impacts the write operations performance.</p>

<h4 id="inheritance">Inheritance</h4>

<p>By default, a properties index is inherited in sub classes (i.e. if an attribute is indexed in a super class, it is also indexed in a sub class). If you need to change the index type of an attribute in a subclass you can override the attribute and annotate it with <code>[SpaceIndex]</code> using the requested index type (to disable indexing use NONE).</p>

<h4 id="basic-index">Basic Index</h4>

<p>There are three basic index types provided:</p>

<ul>
<li><span class="tc-bold">EQUAL</span> - performs equality matching (equal to/not equal to).</li>
<li><span class="tc-bold">ORDERED</span> - performs ordered matching (bigger than/less than).</li>
<li><span class="tc-bold">EQUAL_AND_ORDERED</span> - performs both equality and ordered matching, and uses a larger memory footprint than the other indexing types.</li>
</ul>

<p>Here is an example how you can define indexes:</p>

<pre><code class="language-csharp">using System;
using System.Collections.Generic;

using GigaSpaces.Core.Metadata;

    public class User {

        [SpaceID(AutoGenerate = false)]
        [SpaceRouting]
        public long? Id { set; get; }
        [SpaceIndex(Type = SpaceIndexType.Equal)]
        public String Name{ set; get; }
        public double? Balance{ set; get; }
        [SpaceIndex(Type = SpaceIndexType.Ordered)]
        public double? CreditLimit{ set; get; }

        [SpaceProperty(StorageType = StorageType.Document)]
        public Nullable&lt;EAccountStatus&gt; Status{ set; get; }

        [SpaceProperty(StorageType = StorageType.Document)]
        [SpaceIndex(Path = "ZipCode", Type = SpaceIndexType.Equal)]
        public Address address{ set; get; }

        [SpaceIndex(Path = "[*]")]
        public String[] Comment{ set; get; }

        [SpaceProperty(StorageType = StorageType.Document)]
        [SpaceIndex(Path = "HOME")]
        public Dictionary&lt;String, String&gt; Contacts{ set; get; }

        [SpaceProperty(StorageType = StorageType.Document)]
        [SpaceIndex(Path = "[*].Id")]
        public List&lt;Group&gt; Groups{ set; get; }

        [SpaceProperty(StorageType = StorageType.Document)]
        [SpaceIndex(Path = "[*]")]
        public List&lt;int?&gt; Ratings{ set; get; }

        //........
    }
}
</code></pre>

<h4 id="compound-indexing">Compound Indexing</h4>

<p>A Compound Index is a Space index composed from several attributes or nested attributes. Each attribute of a compound index is called a segment and each segment is described by its path.</p>

<p>Here is an example of a compound index:</p>

<pre><code class="language-csharp">using System;
using System.Collections.Generic;

using GigaSpaces.Core.Metadata;

namespace xaptutorial.model
{
    [CompoundSpaceIndex(Paths = new[] {"Name", "CreditLimit"})]
    [SpaceClass]
    public class User {
        [SpaceID(AutoGenerate = false)]
        [SpaceRouting]
        public long? Id { set; get; }

        // ......
    }
}
// Here is a query that will use this index
SqlQuery&lt;User&gt; query = new SqlQuery&lt;User&gt;("Name = 'John Doe' AND CreditLimit &gt; 1000");
</code></pre>

<p>There are several additional indexing options available. For example you can index nested attributes, Nested Dictionaries, Collections, nested attributes within a Collection, free text search and others.</p>

<div class="tc-admon-refer">
  
  <p><a href="../dev-dotnet/indexing.htm/">Indexing Objects</a></p>
</div>

<h1 id="best-practice">Best Practice</h1>

<p><span class="tc-bold">When you code your Space classes make sure:</span></p>

<ul>
<li><p>there are indexes for all relevant attributes including nested attributes you use for queries</p></li>

<li><p>numeric attribute queried with between / greater / less than should have an ordered index.</p></li>

<li><p>compound indexes should be used for attributes queried using AND query</p></li>

<li><p>Space classes have empty no arg constructor</p></li>

<li><p>all nested classes are serializable</p></li>

<li><p>when possible use writeMultiple.</p></li>

<li><p>use projection for read/readMultiple</p></li>

<li><p>use clear for data removal and not take or takeMultiple</p></li>

<li><p>no huge collections with many items</p></li>

<li><p>use change api instead of update , especially if collections are used.</p></li>
</ul>

</body>
</html>